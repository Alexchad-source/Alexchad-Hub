<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CapCut Pro - Professional Video Editor</title>
    <style>
        /* ==================== CSS RESET AND BASE STYLES ==================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f0f23;
            --accent-primary: #e94560;
            --accent-secondary: #0f3460;
            --accent-hover: #ff6b6b;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --text-muted: #666666;
            --border-color: #2a2a4a;
            --success-color: #4ade80;
            --warning-color: #fbbf24;
            --error-color: #ef4444;
            --timeline-bg: #0d0d1a;
            --track-bg: #1e1e3a;
            --clip-video: #3b82f6;
            --clip-audio: #22c55e;
            --clip-text: #a855f7;
            --clip-image: #f59e0b;
            --clip-effect: #ec4899;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* ==================== SCROLLBAR STYLES ==================== */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-secondary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
        }

        /* ==================== MAIN LAYOUT ==================== */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        /* ==================== HEADER / TOOLBAR ==================== */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            height: 56px;
            flex-shrink: 0;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 20px;
            font-weight: bold;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--accent-primary), #ff8a80);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: var(--accent-primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--accent-secondary);
            color: white;
        }

        .btn-secondary:hover {
            background: #1a4a7a;
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .btn-ghost:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* ==================== MAIN CONTENT AREA ==================== */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* ==================== LEFT SIDEBAR - MEDIA PANEL ==================== */
        .sidebar-left {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-tab {
            flex: 1;
            padding: 12px 8px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .sidebar-tab:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .sidebar-tab.active {
            color: var(--accent-primary);
            border-bottom: 2px solid var(--accent-primary);
        }

        .sidebar-tab-icon {
            font-size: 18px;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .media-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .media-item {
            aspect-ratio: 16/9;
            background: var(--bg-tertiary);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .media-item:hover {
            border-color: var(--accent-primary);
            transform: scale(1.02);
        }

        .media-item.selected {
            border-color: var(--accent-primary);
        }

        .media-item img,
        .media-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .media-item-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 4px 6px;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            font-size: 10px;
            color: var(--text-secondary);
        }

        .media-item-duration {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0,0,0,0.7);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 16px;
        }

        .upload-area:hover {
            border-color: var(--accent-primary);
            background: rgba(233, 69, 96, 0.1);
        }

        .upload-icon {
            font-size: 36px;
            margin-bottom: 8px;
        }

        .upload-text {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* ==================== CENTER - PREVIEW AREA ==================== */
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .preview-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            position: relative;
            overflow: hidden;
        }

        .preview-canvas-wrapper {
            position: relative;
            background: #000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }

        #previewCanvas {
            display: block;
        }

        .preview-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .preview-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
        }

        .preview-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s;
        }

        .preview-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .preview-btn.play-btn {
            width: 48px;
            height: 48px;
            background: var(--accent-primary);
            font-size: 20px;
        }

        .preview-btn.play-btn:hover {
            background: var(--accent-hover);
            transform: scale(1.1);
        }

        .time-display {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: var(--text-secondary);
            min-width: 100px;
            text-align: center;
        }

        .preview-zoom {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 4px;
            background: rgba(0,0,0,0.6);
            padding: 4px;
            border-radius: 6px;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }

        .zoom-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .aspect-ratio-selector {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0,0,0,0.6);
            padding: 4px;
            border-radius: 6px;
        }

        .aspect-ratio-selector select {
            background: transparent;
            border: none;
            color: white;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 12px;
        }

        .aspect-ratio-selector select option {
            background: var(--bg-secondary);
        }

        /* ==================== RIGHT SIDEBAR - PROPERTIES ==================== */
        .sidebar-right {
            width: 300px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .properties-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .properties-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .property-group {
            margin-bottom: 20px;
        }

        .property-group-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .property-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .property-label {
            width: 80px;
            font-size: 12px;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .property-input {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-field {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            transition: all 0.2s;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .input-small {
            width: 60px;
            text-align: center;
        }

        .slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider {
            flex: 1;
            appearance: none;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .slider-value {
            width: 40px;
            text-align: right;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-picker {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            padding: 0;
        }

        .color-hex {
            flex: 1;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .toggle-switch.active {
            background: var(--accent-primary);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        .effect-presets {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .effect-preset {
            aspect-ratio: 1;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-size: 10px;
            color: var(--text-secondary);
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .effect-preset:hover {
            border-color: var(--accent-primary);
        }

        .effect-preset.active {
            border-color: var(--accent-primary);
            background: rgba(233, 69, 96, 0.2);
        }

        .effect-preset-icon {
            font-size: 20px;
        }

        /* ==================== TIMELINE ==================== */
        .timeline-container {
            height: 280px;
            background: var(--timeline-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .timeline-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .timeline-tools {
            display: flex;
            gap: 4px;
        }

        .timeline-tool {
            width: 32px;
            height: 32px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .timeline-tool:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .timeline-tool.active {
            background: var(--accent-primary);
            color: white;
        }

        .timeline-zoom {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zoom-slider {
            width: 100px;
        }

        .timeline-main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .track-labels {
            width: 120px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .track-label {
            height: 50px;
            display: flex;
            align-items: center;
            padding: 0 12px;
            border-bottom: 1px solid var(--border-color);
            font-size: 12px;
            color: var(--text-secondary);
            gap: 8px;
        }

        .track-label-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .track-label-icon.video { background: var(--clip-video); }
        .track-label-icon.audio { background: var(--clip-audio); }
        .track-label-icon.text { background: var(--clip-text); }
        .track-label-icon.effects { background: var(--clip-effect); }

        .track-actions {
            margin-left: auto;
            display: flex;
            gap: 4px;
        }

        .track-action-btn {
            width: 20px;
            height: 20px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 4px;
            font-size: 10px;
        }

        .track-action-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .timeline-tracks-wrapper {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
        }

        .timeline-ruler {
            height: 28px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .timeline-ruler-canvas {
            width: 100%;
            height: 100%;
        }

        .timeline-tracks {
            position: relative;
            min-height: calc(100% - 28px);
        }

        .timeline-track {
            height: 50px;
            background: var(--track-bg);
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }

        .timeline-track.dragover {
            background: rgba(233, 69, 96, 0.1);
        }

        .timeline-clip {
            position: absolute;
            height: 42px;
            top: 4px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 11px;
            color: white;
            overflow: hidden;
            transition: box-shadow 0.2s;
            user-select: none;
        }

        .timeline-clip:hover {
            box-shadow: 0 0 0 2px var(--accent-primary);
        }

        .timeline-clip.selected {
            box-shadow: 0 0 0 2px var(--accent-primary), 0 4px 12px rgba(233, 69, 96, 0.3);
        }

        .timeline-clip.video { background: linear-gradient(135deg, var(--clip-video), #1d4ed8); }
        .timeline-clip.audio { background: linear-gradient(135deg, var(--clip-audio), #15803d); }
        .timeline-clip.text { background: linear-gradient(135deg, var(--clip-text), #7c3aed); }
        .timeline-clip.image { background: linear-gradient(135deg, var(--clip-image), #d97706); }
        .timeline-clip.effect { background: linear-gradient(135deg, var(--clip-effect), #be185d); }

        .clip-thumbnail {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            margin-right: 6px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .clip-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .clip-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
            background: rgba(255,255,255,0.2);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .timeline-clip:hover .clip-handle {
            opacity: 1;
        }

        .clip-handle.left { left: 0; border-radius: 6px 0 0 6px; }
        .clip-handle.right { right: 0; border-radius: 0 6px 6px 0; }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--accent-primary);
            z-index: 20;
            pointer-events: none;
        }

        .playhead::before {
            content: '';
            position: absolute;
            top: 0;
            left: -6px;
            width: 14px;
            height: 14px;
            background: var(--accent-primary);
            clip-path: polygon(50% 100%, 0 0, 100% 0);
        }

        /* ==================== MODALS ==================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            transform: scale(0.9);
            transition: transform 0.3s;
        }

        .modal-overlay.active .modal {
            transform: scale(1);
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 24px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 18px;
        }

        .modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .modal-body {
            padding: 24px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px 24px;
            border-top: 1px solid var(--border-color);
        }

        /* ==================== EXPORT MODAL ==================== */
        .export-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .export-option {
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
            text-align: center;
        }

        .export-option:hover {
            border-color: var(--accent-secondary);
        }

        .export-option.selected {
            border-color: var(--accent-primary);
            background: rgba(233, 69, 96, 0.1);
        }

        .export-option-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .export-option-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .export-option-desc {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .export-settings {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
        }

        .export-progress {
            margin-top: 20px;
        }

        .progress-bar {
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-hover));
            border-radius: 4px;
            transition: width 0.3s;
        }

        .progress-text {
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
        }

        /* ==================== TEXT EDITOR ==================== */
        .text-editor-panel {
            padding: 16px;
        }

        .text-templates {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .text-template {
            height: 80px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
            font-size: 14px;
        }

        .text-template:hover {
            border-color: var(--accent-secondary);
        }

        .text-template.selected {
            border-color: var(--accent-primary);
        }

        .font-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
        }

        .font-option {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .font-option:hover {
            border-color: var(--accent-secondary);
        }

        .font-option.selected {
            border-color: var(--accent-primary);
        }

        /* ==================== FILTERS & EFFECTS ==================== */
        .filter-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }

        .filter-item {
            aspect-ratio: 1;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            overflow: hidden;
            position: relative;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .filter-item:hover {
            border-color: var(--accent-secondary);
            transform: scale(1.05);
        }

        .filter-item.selected {
            border-color: var(--accent-primary);
        }

        .filter-preview {
            width: 100%;
            height: 70%;
            object-fit: cover;
        }

        .filter-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 6px;
            text-align: center;
            font-size: 10px;
            background: rgba(0,0,0,0.7);
        }

        /* ==================== TRANSITIONS ==================== */
        .transition-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        .transition-item {
            aspect-ratio: 16/9;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .transition-item:hover {
            border-color: var(--accent-secondary);
        }

        .transition-item.selected {
            border-color: var(--accent-primary);
        }

        .transition-icon {
            font-size: 24px;
        }

        .transition-name {
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* ==================== STICKERS & ELEMENTS ==================== */
        .sticker-categories {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            overflow-x: auto;
            padding-bottom: 8px;
        }

        .sticker-category {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            white-space: nowrap;
            border: none;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .sticker-category:hover {
            background: var(--accent-secondary);
            color: white;
        }

        .sticker-category.active {
            background: var(--accent-primary);
            color: white;
        }

        .sticker-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .sticker-item {
            aspect-ratio: 1;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            transition: all 0.2s;
        }

        .sticker-item:hover {
            background: var(--accent-secondary);
            transform: scale(1.1);
        }

        /* ==================== AUDIO WAVEFORM ==================== */
        .audio-waveform {
            height: 40px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin: 8px 0;
            position: relative;
            overflow: hidden;
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: var(--clip-audio);
            border-radius: 2px;
        }

        /* ==================== KEYFRAMES ==================== */
        .keyframe-editor {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 16px;
            margin-top: 12px;
        }

        .keyframe-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .keyframe-property {
            width: 80px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .keyframe-timeline {
            flex: 1;
            height: 24px;
            background: var(--bg-secondary);
            border-radius: 4px;
            position: relative;
        }

        .keyframe-point {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: var(--accent-primary);
            border-radius: 2px;
            transform: translate(-50%, -50%) rotate(45deg);
            cursor: pointer;
        }

        .keyframe-point:hover {
            background: var(--accent-hover);
        }

        /* ==================== CONTEXT MENU ==================== */
        .context-menu {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px 0;
            min-width: 180px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .context-menu-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .context-menu-item.danger:hover {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-color);
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border-color);
            margin: 8px 0;
        }

        .context-menu-icon {
            width: 16px;
            text-align: center;
        }

        .context-menu-shortcut {
            margin-left: auto;
            font-size: 11px;
            color: var(--text-muted);
        }

        /* ==================== NOTIFICATIONS ==================== */
        .notification-container {
            position: fixed;
            top: 70px;
            right: 20px;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .notification {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease;
            min-width: 280px;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification.success { border-left: 3px solid var(--success-color); }
        .notification.warning { border-left: 3px solid var(--warning-color); }
        .notification.error { border-left: 3px solid var(--error-color); }
        .notification.info { border-left: 3px solid var(--accent-primary); }

        .notification-icon {
            font-size: 18px;
        }

        .notification.success .notification-icon { color: var(--success-color); }
        .notification.warning .notification-icon { color: var(--warning-color); }
        .notification.error .notification-icon { color: var(--error-color); }
        .notification.info .notification-icon { color: var(--accent-primary); }

        .notification-content {
            flex: 1;
        }

        .notification-title {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 2px;
        }

        .notification-message {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .notification-close {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
        }

        /* ==================== LOADING STATES ==================== */
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--bg-tertiary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .skeleton {
            background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        /* ==================== TOOLTIPS ==================== */
        .tooltip {
            position: relative;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            z-index: 100;
            pointer-events: none;
        }

        .tooltip:hover::after {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-4px);
        }

        /* ==================== RESPONSIVE ==================== */
        @media (max-width: 1200px) {
            .sidebar-left { width: 240px; }
            .sidebar-right { width: 260px; }
        }

        @media (max-width: 992px) {
            .sidebar-right { display: none; }
        }

        @media (max-width: 768px) {
            .sidebar-left { display: none; }
            .header { padding: 8px; }
            .timeline-container { height: 200px; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- ==================== HEADER ==================== -->
        <header class="header">
            <div class="logo">
                <div class="logo-icon">üé¨</div>
                <span>CapCut Pro</span>
            </div>
            
            <div class="header-center">
                <button class="btn btn-ghost" id="undoBtn" title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
                <button class="btn btn-ghost" id="redoBtn" title="Redo (Ctrl+Y)">‚Ü∑ Redo</button>
            </div>
            
            <div class="header-actions">
                <button class="btn btn-secondary" id="saveProjectBtn">üíæ Save</button>
                <button class="btn btn-secondary" id="loadProjectBtn">üìÇ Load</button>
                <button class="btn btn-primary" id="exportBtn">üì§ Export</button>
            </div>
        </header>

        <!-- ==================== MAIN CONTENT ==================== -->
        <div class="main-content">
            <!-- ==================== LEFT SIDEBAR ==================== -->
            <aside class="sidebar-left">
                <div class="sidebar-tabs">
                    <button class="sidebar-tab active" data-tab="media">
                        <span class="sidebar-tab-icon">üìÅ</span>
                        <span>Media</span>
                    </button>
                    <button class="sidebar-tab" data-tab="audio">
                        <span class="sidebar-tab-icon">üéµ</span>
                        <span>Audio</span>
                    </button>
                    <button class="sidebar-tab" data-tab="text">
                        <span class="sidebar-tab-icon">‚úèÔ∏è</span>
                        <span>Text</span>
                    </button>
                    <button class="sidebar-tab" data-tab="stickers">
                        <span class="sidebar-tab-icon">‚≠ê</span>
                        <span>Stickers</span>
                    </button>
                    <button class="sidebar-tab" data-tab="effects">
                        <span class="sidebar-tab-icon">‚ú®</span>
                        <span>Effects</span>
                    </button>
                </div>

                <div class="sidebar-content">
                    <!-- Media Tab -->
                    <div class="tab-content active" id="media-tab">
                        <div class="upload-area" id="uploadArea">
                            <div class="upload-icon">üì§</div>
                            <div class="upload-text">Drop files here or click to upload</div>
                            <input type="file" id="fileInput" multiple accept="video/*,image/*,audio/*" hidden>
                        </div>
                        <div class="media-grid" id="mediaGrid"></div>
                    </div>

                    <!-- Audio Tab -->
                    <div class="tab-content" id="audio-tab" style="display:none;">
                        <div class="upload-area" id="audioUploadArea">
                            <div class="upload-icon">üéµ</div>
                            <div class="upload-text">Upload audio files</div>
                            <input type="file" id="audioInput" multiple accept="audio/*" hidden>
                        </div>
                        <h4 style="margin: 16px 0 12px; font-size: 13px;">Sound Effects</h4>
                        <div class="media-grid" id="audioGrid"></div>
                    </div>

                    <!-- Text Tab -->
                    <div class="tab-content" id="text-tab" style="display:none;">
                        <h4 style="margin-bottom: 12px; font-size: 13px;">Text Templates</h4>
                        <div class="text-templates">
                            <div class="text-template" data-template="title" style="font-size: 24px; font-weight: bold;">Title</div>
                            <div class="text-template" data-template="subtitle" style="font-size: 16px;">Subtitle</div>
                            <div class="text-template" data-template="caption" style="font-size: 12px; font-style: italic;">Caption</div>
                            <div class="text-template" data-template="custom">+ Custom</div>
                        </div>
                        <h4 style="margin: 16px 0 12px; font-size: 13px;">Animated Text</h4>
                        <div class="text-templates">
                            <div class="text-template" data-template="typewriter">Typewriter</div>
                            <div class="text-template" data-template="fade">Fade In</div>
                            <div class="text-template" data-template="bounce">Bounce</div>
                            <div class="text-template" data-template="slide">Slide In</div>
                        </div>
                    </div>

                    <!-- Stickers Tab -->
                    <div class="tab-content" id="stickers-tab" style="display:none;">
                        <div class="sticker-categories">
                            <button class="sticker-category active" data-category="emoji">Emoji</button>
                            <button class="sticker-category" data-category="shapes">Shapes</button>
                            <button class="sticker-category" data-category="arrows">Arrows</button>
                            <button class="sticker-category" data-category="social">Social</button>
                        </div>
                        <div class="sticker-grid" id="stickerGrid"></div>
                    </div>

                    <!-- Effects Tab -->
                    <div class="tab-content" id="effects-tab" style="display:none;">
                        <h4 style="margin-bottom: 12px; font-size: 13px;">Filters</h4>
                        <div class="filter-grid" id="filterGrid"></div>
                        <h4 style="margin: 16px 0 12px; font-size: 13px;">Transitions</h4>
                        <div class="transition-grid" id="transitionGrid"></div>
                    </div>
                </div>
            </aside>

            <!-- ==================== CENTER PANEL ==================== -->
            <main class="center-panel">
                <div class="preview-container">
                    <div class="aspect-ratio-selector">
                        <select id="aspectRatio">
                            <option value="16:9">16:9 Landscape</option>
                            <option value="9:16">9:16 Portrait</option>
                            <option value="1:1">1:1 Square</option>
                            <option value="4:3">4:3 Standard</option>
                            <option value="21:9">21:9 Cinematic</option>
                        </select>
                    </div>
                    
                    <div class="preview-zoom">
                        <button class="zoom-btn" id="zoomOut">‚àí</button>
                        <span id="zoomLevel">100%</span>
                        <button class="zoom-btn" id="zoomIn">+</button>
                        <button class="zoom-btn" id="zoomFit">‚ä°</button>
                    </div>

                    <div class="preview-canvas-wrapper" id="canvasWrapper">
                        <canvas id="previewCanvas" width="1280" height="720"></canvas>
                        <div class="preview-overlay" id="previewOverlay"></div>
                    </div>

                    <div class="preview-controls">
                        <button class="preview-btn tooltip" data-tooltip="Previous Frame" id="prevFrameBtn">‚èÆ</button>
                        <button class="preview-btn tooltip" data-tooltip="Step Back" id="stepBackBtn">‚óÄ‚óÄ</button>
                        <button class="preview-btn play-btn" id="playBtn">‚ñ∂</button>
                        <button class="preview-btn tooltip" data-tooltip="Step Forward" id="stepForwardBtn">‚ñ∂‚ñ∂</button>
                        <button class="preview-btn tooltip" data-tooltip="Next Frame" id="nextFrameBtn">‚è≠</button>
                        <div class="time-display">
                            <span id="currentTime">00:00:00</span> / <span id="totalTime">00:00:00</span>
                        </div>
                        <button class="preview-btn tooltip" data-tooltip="Volume" id="volumeBtn">üîä</button>
                        <button class="preview-btn tooltip" data-tooltip="Fullscreen" id="fullscreenBtn">‚õ∂</button>
                    </div>
                </div>
            </main>

            <!-- ==================== RIGHT SIDEBAR ==================== -->
            <aside class="sidebar-right">
                <div class="properties-header">
                    <span>üìê</span>
                    <span>Properties</span>
                </div>
                <div class="properties-content" id="propertiesContent">
                    <!-- Transform Group -->
                    <div class="property-group">
                        <div class="property-group-title">
                            <span>üìç</span> Transform
                        </div>
                        <div class="property-row">
                            <span class="property-label">Position X</span>
                            <div class="property-input">
                                <input type="number" class="input-field input-small" id="propPosX" value="0">
                            </div>
                        </div>
                        <div class="property-row">
                            <span class="property-label">Position Y</span>
                            <div class="property-input">
                                <input type="number" class="input-field input-small" id="propPosY" value="0">
                            </div>
                        </div>
                        <div class="property-row">
                            <span class="property-label">Scale</span>
                            <div class="property-input slider-container">
                                <input type="range" class="slider" id="propScale" min="10" max="300" value="100">
                                <span class="slider-value" id="propScaleValue">100%</span>
                            </div>
                        </div>
                        <div class="property-row">
                            <span class="property-label">Rotation</span>
                            <div class="property-input slider-container">
                                <input type="range" class="slider" id="propRotation" min="-180" max="180" value="0">
                                <span class="slider-value" id="propRotationValue">0¬∞</span>
                            </div>
                        </div>
                    </div>

                    <!-- Opacity Group -->
                    <div class="property-group">
                        <div class="property-group-title">
                            <span>üíß</span> Opacity
                        </div>
                        <div class="property-row">
                            <span class="property-label">Opacity</span>
                            <div class="property-input slider-container">
                                <input type="range" class="slider" id="propOpacity" min="0" max="100" value="100">
                                <span class="slider-value" id="propOpacityValue">100%</span>
                            </div>
                        </div>
                        <div class="property-row">
                            <span class="property-label">Blend</span>
                            <div class="property-input">
                                <select class="input-field" id="propBlendMode">
                                    <option value="normal">Normal</option>
                                    <option value="multiply">Multiply</option>
                                    <option value="screen">Screen</option>
                                    <option value="overlay">Overlay</option>
                                    <option value="darken">Darken</option>
                                    <option value="lighten">Lighten</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Color Adjustment -->
                    <div class="property-group">
                        <div class="property-group-title">
                            <span>üé®</span> Color
                        </div>
                        <div class="property-row">
                            <span class="property-label">Brightness</span>
                            <div class="property-input slider-container">
                                <input type="range" class="slider" id="propBrightness" min="-100" max="100" value="0">
                                <span class="slider-value" id="propBrightnessValue">0</span>
                            </div>
                        </div>
                        <div class="property-row">
                            <span class="property-label">Contrast</span>
                            <div class="property-input slider-container">
                                <input type="range" class="slider" id="propContrast" min="-100" max="100" value="0">
                                <span class="slider-value" id="propContrastValue">0</span>
                            </div>
                        </div>
                        <div class="property-row">
                            <span class="property-label">Saturation</span>
                            <div class="property-input slider-container">
                                <input type="range" class="slider" id="propSaturation" min="-100" max="100" value="0">
                                <span class="slider-value" id="propSaturationValue">0</span>
                            </div>
                        </div>
                        <div class="property-row">
                            <span class="property-label">Hue</span>
                            <div class="property-input slider-container">
                                <input type="range" class="slider" id="propHue" min="-180" max="180" value="0">
                                <span class="slider-value" id="propHueValue">0¬∞</span>
                            </div>
                        </div>
                    </div>

                    <!-- Speed -->
                    <div class="property-group">
                        <div class="property-group-title">
                            <span>‚è±Ô∏è</span> Speed
                        </div>
                        <div class="property-row">
                            <span class="property-label">Speed</span>
                            <div class="property-input slider-container">
                                <input type="range" class="slider" id="propSpeed" min="25" max="400" value="100">
                                <span class="slider-value" id="propSpeedValue">1.0x</span>
                            </div>
                        </div>
                        <div class="property-row">
                            <span class="property-label">Reverse</span>
                            <div class="property-input">
                                <div class="toggle-switch" id="propReverse"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Keyframes -->
                    <div class="property-group">
                        <div class="property-group-title">
                            <span>‚óÜ</span> Keyframes
                            <button class="btn btn-ghost" style="margin-left: auto; padding: 4px 8px; font-size: 11px;" id="addKeyframeBtn">+ Add</button>
                        </div>
                        <div class="keyframe-editor" id="keyframeEditor">
                            <div class="keyframe-row">
                                <span class="keyframe-property">Scale</span>
                                <div class="keyframe-timeline">
                                    <div class="keyframe-point" style="left: 10%;"></div>
                                    <div class="keyframe-point" style="left: 90%;"></div>
                                </div>
                            </div>
                            <div class="keyframe-row">
                                <span class="keyframe-property">Position</span>
                                <div class="keyframe-timeline">
                                    <div class="keyframe-point" style="left: 0%;"></div>
                                    <div class="keyframe-point" style="left: 50%;"></div>
                                    <div class="keyframe-point" style="left: 100%;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>
        </div>

        <!-- ==================== TIMELINE ==================== -->
        <div class="timeline-container">
            <div class="timeline-toolbar">
                <div class="timeline-tools">
                    <button class="timeline-tool active tooltip" data-tooltip="Select (V)" data-tool="select">‚¨ö</button>
                    <button class="timeline-tool tooltip" data-tooltip="Razor (C)" data-tool="razor">‚úÇÔ∏è</button>
                    <button class="timeline-tool tooltip" data-tooltip="Hand (H)" data-tool="hand">‚úã</button>
                    <div style="width: 1px; height: 20px; background: var(--border-color); margin: 0 8px;"></div>
                    <button class="timeline-tool tooltip" data-tooltip="Split (S)" id="splitBtn">‚´Ω</button>
                    <button class="timeline-tool tooltip" data-tooltip="Delete (Del)" id="deleteBtn">üóëÔ∏è</button>
                    <button class="timeline-tool tooltip" data-tooltip="Duplicate (Ctrl+D)" id="duplicateBtn">üìã</button>
                    <div style="width: 1px; height: 20px; background: var(--border-color); margin: 0 8px;"></div>
                    <button class="timeline-tool tooltip" data-tooltip="Add Track" id="addTrackBtn">‚ûï</button>
                    <button class="timeline-tool tooltip" data-tooltip="Snap to Grid" id="snapBtn">üß≤</button>
                </div>
                <div class="timeline-zoom">
                    <span style="font-size: 12px; color: var(--text-secondary);">üîç</span>
                    <input type="range" class="slider zoom-slider" id="timelineZoom" min="10" max="200" value="50">
                    <span id="timelineZoomValue" style="font-size: 12px; min-width: 40px;">50%</span>
                </div>
            </div>

            <div class="timeline-main">
                <div class="track-labels" id="trackLabels">
                    <div class="track-label" style="height: 28px; border-bottom: 1px solid var(--border-color);"></div>
                </div>

                <div class="timeline-tracks-wrapper" id="timelineWrapper">
                    <div class="timeline-ruler">
                        <canvas id="rulerCanvas" class="timeline-ruler-canvas"></canvas>
                    </div>
                    <div class="timeline-tracks" id="timelineTracks">
                        <div class="playhead" id="playhead" style="left: 0;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ==================== EXPORT MODAL ==================== -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Export Video</span>
                <button class="modal-close" id="closeExportModal">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="export-options">
                    <div class="export-option selected" data-format="mp4">
                        <div class="export-option-icon">üé¨</div>
                        <div class="export-option-title">MP4</div>
                        <div class="export-option-desc">Best compatibility</div>
                    </div>
                    <div class="export-option" data-format="webm">
                        <div class="export-option-icon">üåê</div>
                        <div class="export-option-title">WebM</div>
                        <div class="export-option-desc">Web optimized</div>
                    </div>
                    <div class="export-option" data-format="gif">
                        <div class="export-option-icon">üéûÔ∏è</div>
                        <div class="export-option-title">GIF</div>
                        <div class="export-option-desc">Animated image</div>
                    </div>
                    <div class="export-option" data-format="frames">
                        <div class="export-option-icon">üñºÔ∏è</div>
                        <div class="export-option-title">Frames</div>
                        <div class="export-option-desc">Image sequence</div>
                    </div>
                </div>
                <div class="export-settings">
                    <div class="property-row">
                        <span class="property-label">Resolution</span>
                        <div class="property-input">
                            <select class="input-field" id="exportResolution">
                                <option value="1080">1080p (1920x1080)</option>
                                <option value="720">720p (1280x720)</option>
                                <option value="480">480p (854x480)</option>
                                <option value="4k">4K (3840x2160)</option>
                            </select>
                        </div>
                    </div>
                    <div class="property-row">
                        <span class="property-label">Frame Rate</span>
                        <div class="property-input">
                            <select class="input-field" id="exportFps">
                                <option value="30">30 FPS</option>
                                <option value="60">60 FPS</option>
                                <option value="24">24 FPS</option>
                            </select>
                        </div>
                    </div>
                    <div class="property-row">
                        <span class="property-label">Quality</span>
                        <div class="property-input slider-container">
                            <input type="range" class="slider" id="exportQuality" min="1" max="100" value="80">
                            <span class="slider-value" id="exportQualityValue">80%</span>
                        </div>
                    </div>
                </div>
                <div class="export-progress" id="exportProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="exportProgressFill" style="width: 0%;"></div>
                    </div>
                    <div class="progress-text" id="exportProgressText">Preparing export...</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-ghost" id="cancelExport">Cancel</button>
                <button class="btn btn-primary" id="startExport">üöÄ Export</button>
            </div>
        </div>
    </div>

    <!-- ==================== TEXT EDITOR MODAL ==================== -->
    <div class="modal-overlay" id="textModal">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <span class="modal-title">Add Text</span>
                <button class="modal-close" id="closeTextModal">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="property-row">
                    <span class="property-label">Text</span>
                    <div class="property-input">
                        <textarea class="input-field" id="textContent" rows="3" placeholder="Enter your text..."></textarea>
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Font</span>
                    <div class="property-input">
                        <select class="input-field" id="textFont">
                            <option value="Arial">Arial</option>
                            <option value="Helvetica">Helvetica</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Impact">Impact</option>
                            <option value="Comic Sans MS">Comic Sans MS</option>
                        </select>
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Size</span>
                    <div class="property-input slider-container">
                        <input type="range" class="slider" id="textSize" min="12" max="200" value="48">
                        <span class="slider-value" id="textSizeValue">48px</span>
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Color</span>
                    <div class="property-input color-picker-wrapper">
                        <input type="color" class="color-picker" id="textColor" value="#ffffff">
                        <input type="text" class="input-field color-hex" id="textColorHex" value="#ffffff">
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Style</span>
                    <div class="property-input" style="display: flex; gap: 8px;">
                        <button class="btn btn-ghost" id="textBold" style="font-weight: bold;">B</button>
                        <button class="btn btn-ghost" id="textItalic" style="font-style: italic;">I</button>
                        <button class="btn btn-ghost" id="textUnderline" style="text-decoration: underline;">U</button>
                    </div>
                </div>
                <div class="property-row">
                    <span class="property-label">Animation</span>
                    <div class="property-input">
                        <select class="input-field" id="textAnimation">
                            <option value="none">None</option>
                            <option value="fadeIn">Fade In</option>
                            <option value="slideUp">Slide Up</option>
                            <option value="slideDown">Slide Down</option>
                            <option value="typewriter">Typewriter</option>
                            <option value="bounce">Bounce</option>
                            <option value="zoom">Zoom</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-ghost" id="cancelText">Cancel</button>
                <button class="btn btn-primary" id="addText">Add Text</button>
            </div>
        </div>
    </div>

    <!-- ==================== CONTEXT MENU ==================== -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" data-action="cut">
            <span class="context-menu-icon">‚úÇÔ∏è</span>
            <span>Cut</span>
            <span class="context-menu-shortcut">Ctrl+X</span>
        </div>
        <div class="context-menu-item" data-action="copy">
            <span class="context-menu-icon">üìã</span>
            <span>Copy</span>
            <span class="context-menu-shortcut">Ctrl+C</span>
        </div>
        <div class="context-menu-item" data-action="paste">
            <span class="context-menu-icon">üìÑ</span>
            <span>Paste</span>
            <span class="context-menu-shortcut">Ctrl+V</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="duplicate">
            <span class="context-menu-icon">üìë</span>
            <span>Duplicate</span>
            <span class="context-menu-shortcut">Ctrl+D</span>
        </div>
        <div class="context-menu-item" data-action="split">
            <span class="context-menu-icon">‚´Ω</span>
            <span>Split</span>
            <span class="context-menu-shortcut">S</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="speed">
            <span class="context-menu-icon">‚è±Ô∏è</span>
            <span>Speed</span>
        </div>
        <div class="context-menu-item" data-action="reverse">
            <span class="context-menu-icon">‚Ü©Ô∏è</span>
            <span>Reverse</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item danger" data-action="delete">
            <span class="context-menu-icon">üóëÔ∏è</span>
            <span>Delete</span>
            <span class="context-menu-shortcut">Del</span>
        </div>
    </div>

    <!-- ==================== NOTIFICATION CONTAINER ==================== -->
    <div class="notification-container" id="notificationContainer"></div>

    <!-- ==================== HIDDEN FILE INPUT ==================== -->
    <input type="file" id="projectInput" accept=".json" hidden>

    <script>
        // ==================== CAPCUT PRO - VIDEO EDITOR ====================
        // Complete Video Editing Application
        // ==================== GLOBAL STATE ====================
        const AppState = {
            project: {
                name: 'Untitled Project',
                created: new Date().toISOString(),
                modified: new Date().toISOString(),
                settings: {
                    width: 1920,
                    height: 1080,
                    fps: 30,
                    duration: 0,
                    aspectRatio: '16:9'
                }
            },
            timeline: {
                tracks: [],
                currentTime: 0,
                duration: 300, // 5 minutes in seconds
                zoom: 50,
                pixelsPerSecond: 50,
                snap: true
            },
            playback: {
                isPlaying: false,
                volume: 1,
                playbackRate: 1
            },
            selection: {
                selectedClips: [],
                selectedTrack: null,
                clipboard: null
            },
            media: {
                files: [],
                audioFiles: []
            },
            history: {
                undoStack: [],
                redoStack: [],
                maxHistory: 50
            },
            ui: {
                currentTool: 'select',
                sidebarTab: 'media',
                previewZoom: 100,
                isDragging: false,
                dragData: null
            }
        };

        // ==================== UTILITY FUNCTIONS ====================
        const Utils = {
            generateId() {
                return 'id_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
            },

            formatTime(seconds) {
                const hrs = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            },

            formatDuration(seconds) {
                if (seconds < 60) return `${seconds.toFixed(1)}s`;
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            },

            clamp(value, min, max) {
                return Math.min(Math.max(value, min), max);
            },

            lerp(start, end, t) {
                return start + (end - start) * t;
            },

            easeInOut(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            },

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            },

            rgbToHex(r, g, b) {
                return '#' + [r, g, b].map(x => {
                    const hex = x.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            },

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            throttle(func, limit) {
                let inThrottle;
                return function(...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },

            async loadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = src;
                });
            },

            async loadVideo(src) {
                return new Promise((resolve, reject) => {
                    const video = document.createElement('video');
                    video.onloadedmetadata = () => resolve(video);
                    video.onerror = reject;
                    video.src = src;
                    video.load();
                });
            },

            downloadFile(data, filename, type) {
                const blob = new Blob([data], { type });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }
        };

        // ==================== NOTIFICATION SYSTEM ====================
        const NotificationManager = {
            container: null,

            init() {
                this.container = document.getElementById('notificationContainer');
            },

            show(title, message, type = 'info', duration = 4000) {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                
                const icons = {
                    success: '‚úì',
                    warning: '‚ö†',
                    error: '‚úï',
                    info: '‚Ñπ'
                };

                notification.innerHTML = `
                    <span class="notification-icon">${icons[type]}</span>
                    <div class="notification-content">
                        <div class="notification-title">${title}</div>
                        <div class="notification-message">${message}</div>
                    </div>
                    <button class="notification-close">‚úï</button>
                `;

                this.container.appendChild(notification);

                notification.querySelector('.notification-close').addEventListener('click', () => {
                    this.dismiss(notification);
                });

                if (duration > 0) {
                    setTimeout(() => this.dismiss(notification), duration);
                }

                return notification;
            },

            dismiss(notification) {
                notification.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => notification.remove(), 300);
            },

            success(title, message) {
                return this.show(title, message, 'success');
            },

            warning(title, message) {
                return this.show(title, message, 'warning');
            },

            error(title, message) {
                return this.show(title, message, 'error');
            },

            info(title, message) {
                return this.show(title, message, 'info');
            }
        };

        // ==================== HISTORY MANAGER (UNDO/REDO) ====================
        const HistoryManager = {
            saveState(action) {
                const state = JSON.parse(JSON.stringify({
                    tracks: AppState.timeline.tracks,
                    action: action
                }));
                
                AppState.history.undoStack.push(state);
                AppState.history.redoStack = [];
                
                if (AppState.history.undoStack.length > AppState.history.maxHistory) {
                    AppState.history.undoStack.shift();
                }
                
                this.updateButtons();
            },

            undo() {
                if (AppState.history.undoStack.length === 0) return;
                
                const currentState = JSON.parse(JSON.stringify({
                    tracks: AppState.timeline.tracks
                }));
                AppState.history.redoStack.push(currentState);
                
                const previousState = AppState.history.undoStack.pop();
                AppState.timeline.tracks = previousState.tracks;
                
                TimelineManager.render();
                this.updateButtons();
                NotificationManager.info('Undo', `Undid: ${previousState.action}`);
            },

            redo() {
                if (AppState.history.redoStack.length === 0) return;
                
                const currentState = JSON.parse(JSON.stringify({
                    tracks: AppState.timeline.tracks
                }));
                AppState.history.undoStack.push(currentState);
                
                const nextState = AppState.history.redoStack.pop();
                AppState.timeline.tracks = nextState.tracks;
                
                TimelineManager.render();
                this.updateButtons();
                NotificationManager.info('Redo', 'Action restored');
            },

            updateButtons() {
                document.getElementById('undoBtn').disabled = AppState.history.undoStack.length === 0;
                document.getElementById('redoBtn').disabled = AppState.history.redoStack.length === 0;
            }
        };

        // ==================== MEDIA MANAGER ====================
        const MediaManager = {
            init() {
                this.setupUploadHandlers();
                this.loadDefaultMedia();
            },

            setupUploadHandlers() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const audioUploadArea = document.getElementById('audioUploadArea');
                const audioInput = document.getElementById('audioInput');

                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = 'var(--accent-primary)';
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.style.borderColor = 'var(--border-color)';
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = 'var(--border-color)';
                    this.handleFiles(e.dataTransfer.files);
                });

                fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });

                audioUploadArea.addEventListener('click', () => audioInput.click());
                audioInput.addEventListener('change', (e) => {
                    this.handleAudioFiles(e.target.files);
                });
            },

            async handleFiles(files) {
                for (const file of files) {
                    const mediaItem = await this.processFile(file);
                    if (mediaItem) {
                        AppState.media.files.push(mediaItem);
                        this.renderMediaGrid();
                        NotificationManager.success('Media Added', `${file.name} imported successfully`);
                    }
                }
            },

            async handleAudioFiles(files) {
                for (const file of files) {
                    if (file.type.startsWith('audio/')) {
                        const audioItem = await this.processAudioFile(file);
                        if (audioItem) {
                            AppState.media.audioFiles.push(audioItem);
                            this.renderAudioGrid();
                            NotificationManager.success('Audio Added', `${file.name} imported successfully`);
                        }
                    }
                }
            },

            async processFile(file) {
                const url = URL.createObjectURL(file);
                const id = Utils.generateId();
                
                if (file.type.startsWith('video/')) {
                    try {
                        const video = await Utils.loadVideo(url);
                        const thumbnail = await this.generateVideoThumbnail(video);
                        return {
                            id,
                            type: 'video',
                            name: file.name,
                            url,
                            thumbnail,
                            duration: video.duration,
                            width: video.videoWidth,
                            height: video.videoHeight,
                            file
                        };
                    } catch (error) {
                        NotificationManager.error('Error', `Failed to load video: ${file.name}`);
                        return null;
                    }
                } else if (file.type.startsWith('image/')) {
                    try {
                        const img = await Utils.loadImage(url);
                        return {
                            id,
                            type: 'image',
                            name: file.name,
                            url,
                            thumbnail: url,
                            duration: 5,
                            width: img.width,
                            height: img.height,
                            file
                        };
                    } catch (error) {
                        NotificationManager.error('Error', `Failed to load image: ${file.name}`);
                        return null;
                    }
                }
                return null;
            },

            async processAudioFile(file) {
                const url = URL.createObjectURL(file);
                const id = Utils.generateId();
                
                return new Promise((resolve) => {
                    const audio = new Audio(url);
                    audio.onloadedmetadata = () => {
                        resolve({
                            id,
                            type: 'audio',
                            name: file.name,
                            url,
                            duration: audio.duration,
                            file
                        });
                    };
                    audio.onerror = () => {
                        NotificationManager.error('Error', `Failed to load audio: ${file.name}`);
                        resolve(null);
                    };
                });
            },

            async generateVideoThumbnail(video) {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 160;
                    canvas.height = 90;
                    const ctx = canvas.getContext('2d');
                    
                    video.currentTime = 1;
                    video.onseeked = () => {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        resolve(canvas.toDataURL('image/jpeg', 0.7));
                    };
                });
            },

            loadDefaultMedia() {
                // Add some placeholder media items for demo
                const defaultItems = [
                    { id: Utils.generateId(), type: 'video', name: 'Sample Video 1', duration: 30, thumbnail: null },
                    { id: Utils.generateId(), type: 'video', name: 'Sample Video 2', duration: 45, thumbnail: null },
                    { id: Utils.generateId(), type: 'image', name: 'Sample Image 1', duration: 5, thumbnail: null },
                    { id: Utils.generateId(), type: 'image', name: 'Sample Image 2', duration: 5, thumbnail: null }
                ];
                
                defaultItems.forEach(item => {
                    item.thumbnail = this.generatePlaceholderThumbnail(item.type);
                    item.url = item.thumbnail;
                });
                
                AppState.media.files = defaultItems;
                this.renderMediaGrid();
                
                // Default audio
                const defaultAudio = [
                    { id: Utils.generateId(), type: 'audio', name: 'Background Music', duration: 120 },
                    { id: Utils.generateId(), type: 'audio', name: 'Sound Effect 1', duration: 3 },
                    { id: Utils.generateId(), type: 'audio', name: 'Sound Effect 2', duration: 2 }
                ];
                AppState.media.audioFiles = defaultAudio;
                this.renderAudioGrid();
            },

            generatePlaceholderThumbnail(type) {
                const canvas = document.createElement('canvas');
                canvas.width = 160;
                canvas.height = 90;
                const ctx = canvas.getContext('2d');
                
                const gradient = ctx.createLinearGradient(0, 0, 160, 90);
                if (type === 'video') {
                    gradient.addColorStop(0, '#3b82f6');
                    gradient.addColorStop(1, '#1d4ed8');
                } else {
                    gradient.addColorStop(0, '#f59e0b');
                    gradient.addColorStop(1, '#d97706');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 160, 90);
                
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(type === 'video' ? '‚ñ∂' : 'üñº', 80, 45);
                
                return canvas.toDataURL();
            },

            renderMediaGrid() {
                const grid = document.getElementById('mediaGrid');
                grid.innerHTML = AppState.media.files.map(item => `
                    <div class="media-item" data-id="${item.id}" draggable="true">
                        <img src="${item.thumbnail}" alt="${item.name}">
                        <div class="media-item-duration">${Utils.formatDuration(item.duration)}</div>
                        <div class="media-item-overlay">${item.name}</div>
                    </div>
                `).join('');

                grid.querySelectorAll('.media-item').forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        const mediaItem = AppState.media.files.find(m => m.id === item.dataset.id);
                        AppState.ui.dragData = mediaItem;
                        e.dataTransfer.effectAllowed = 'copy';
                    });
                    
                    item.addEventListener('dblclick', () => {
                        const mediaItem = AppState.media.files.find(m => m.id === item.dataset.id);
                        this.addToTimeline(mediaItem);
                    });
                });
            },

            renderAudioGrid() {
                const grid = document.getElementById('audioGrid');
                grid.innerHTML = AppState.media.audioFiles.map(item => `
                    <div class="media-item" data-id="${item.id}" draggable="true" style="aspect-ratio: 2/1;">
                        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; background: linear-gradient(135deg, #22c55e, #15803d);">
                            <span style="font-size: 20px;">üéµ</span>
                            <span style="font-size: 10px; margin-top: 4px;">${Utils.formatDuration(item.duration)}</span>
                        </div>
                        <div class="media-item-overlay">${item.name}</div>
                    </div>
                `).join('');

                grid.querySelectorAll('.media-item').forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        const audioItem = AppState.media.audioFiles.find(m => m.id === item.dataset.id);
                        AppState.ui.dragData = { ...audioItem, type: 'audio' };
                        e.dataTransfer.effectAllowed = 'copy';
                    });
                    
                    item.addEventListener('dblclick', () => {
                        const audioItem = AppState.media.audioFiles.find(m => m.id === item.dataset.id);
                        this.addToTimeline({ ...audioItem, type: 'audio' });
                    });
                });
            },

            addToTimeline(mediaItem) {
                const trackType = mediaItem.type === 'audio' ? 'audio' : 'video';
                let track = AppState.timeline.tracks.find(t => t.type === trackType);
                
                if (!track) {
                    track = TimelineManager.createTrack(trackType);
                }
                
                const lastClip = track.clips[track.clips.length - 1];
                const startTime = lastClip ? lastClip.startTime + lastClip.duration : 0;
                
                const clip = {
                    id: Utils.generateId(),
                    mediaId: mediaItem.id,
                    type: mediaItem.type,
                    name: mediaItem.name,
                    startTime: startTime,
                    duration: mediaItem.duration,
                    inPoint: 0,
                    outPoint: mediaItem.duration,
                    thumbnail: mediaItem.thumbnail,
                    url: mediaItem.url,
                    properties: {
                        x: 0,
                        y: 0,
                        scale: 100,
                        rotation: 0,
                        opacity: 100,
                        brightness: 0,
                        contrast: 0,
                        saturation: 0,
                        hue: 0,
                        speed: 100,
                        reverse: false,
                        volume: 100
                    },
                    keyframes: [],
                    filters: [],
                    effects: []
                };
                
                track.clips.push(clip);
                HistoryManager.saveState(`Added ${mediaItem.name} to timeline`);
                TimelineManager.render();
                TimelineManager.updateDuration();
                NotificationManager.success('Clip Added', `${mediaItem.name} added to timeline`);
            }
        };

        // ==================== TIMELINE MANAGER ====================
        const TimelineManager = {
            wrapper: null,
            tracksContainer: null,
            rulerCanvas: null,
            playhead: null,
            animationFrame: null,

            init() {
                this.wrapper = document.getElementById('timelineWrapper');
                this.tracksContainer = document.getElementById('timelineTracks');
                this.rulerCanvas = document.getElementById('rulerCanvas');
                this.playhead = document.getElementById('playhead');
                
                this.setupEventListeners();
                this.createDefaultTracks();
                this.render();
                this.renderRuler();
            },

            setupEventListeners() {
                // Timeline zoom
                document.getElementById('timelineZoom').addEventListener('input', (e) => {
                    AppState.timeline.zoom = parseInt(e.target.value);
                    AppState.timeline.pixelsPerSecond = AppState.timeline.zoom;
                    document.getElementById('timelineZoomValue').textContent = `${AppState.timeline.zoom}%`;
                    this.render();
                    this.renderRuler();
                });

                // Tool selection
                document.querySelectorAll('.timeline-tool[data-tool]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.timeline-tool[data-tool]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        AppState.ui.currentTool = btn.dataset.tool;
                    });
                });

                // Timeline click to seek
                this.wrapper.addEventListener('click', (e) => {
                    if (e.target === this.tracksContainer || e.target.classList.contains('timeline-track')) {
                        const rect = this.wrapper.getBoundingClientRect();
                        const x = e.clientX - rect.left + this.wrapper.scrollLeft;
                        const time = x / AppState.timeline.pixelsPerSecond;
                        this.seekTo(time);
                    }
                });

                // Drag and drop on timeline
                this.tracksContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const track = e.target.closest('.timeline-track');
                    if (track) {
                        track.classList.add('dragover');
                    }
                });

                this.tracksContainer.addEventListener('dragleave', (e) => {
                    const track = e.target.closest('.timeline-track');
                    if (track) {
                        track.classList.remove('dragover');
                    }
                });

                this.tracksContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const track = e.target.closest('.timeline-track');
                    if (track) {
                        track.classList.remove('dragover');
                        if (AppState.ui.dragData) {
                            const rect = track.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const startTime = x / AppState.timeline.pixelsPerSecond;
                            this.dropMediaOnTrack(track.dataset.trackId, startTime);
                        }
                    }
                });

                // Buttons
                document.getElementById('splitBtn').addEventListener('click', () => this.splitClip());
                document.getElementById('deleteBtn').addEventListener('click', () => this.deleteSelected());
                document.getElementById('duplicateBtn').addEventListener('click', () => this.duplicateSelected());
                document.getElementById('addTrackBtn').addEventListener('click', () => this.showAddTrackMenu());
                document.getElementById('snapBtn').addEventListener('click', (e) => {
                    AppState.timeline.snap = !AppState.timeline.snap;
                    e.target.classList.toggle('active', AppState.timeline.snap);
                });
            },

            createDefaultTracks() {
                AppState.timeline.tracks = [
                    this.createTrack('video', 'Video 1'),
                    this.createTrack('video', 'Video 2'),
                    this.createTrack('audio', 'Audio 1'),
                    this.createTrack('text', 'Text'),
                    this.createTrack('effects', 'Effects')
                ];
            },

            createTrack(type, name = null) {
                const trackNames = {
                    video: 'Video',
                    audio: 'Audio',
                    text: 'Text',
                    effects: 'Effects'
                };
                
                const count = AppState.timeline.tracks.filter(t => t.type === type).length + 1;
                
                return {
                    id: Utils.generateId(),
                    type: type,
                    name: name || `${trackNames[type]} ${count}`,
                    clips: [],
                    locked: false,
                    visible: true,
                    muted: false
                };
            },

            render() {
                // Render track labels
                const labelsContainer = document.getElementById('trackLabels');
                labelsContainer.innerHTML = `
                    <div class="track-label" style="height: 28px; border-bottom: 1px solid var(--border-color);"></div>
                    ${AppState.timeline.tracks.map(track => `
                        <div class="track-label" data-track-id="${track.id}">
                            <div class="track-label-icon ${track.type}">${this.getTrackIcon(track.type)}</div>
                            <span>${track.name}</span>
                            <div class="track-actions">
                                <button class="track-action-btn" data-action="mute" title="${track.muted ? 'Unmute' : 'Mute'}">${track.muted ? 'üîá' : 'üîä'}</button>
                                <button class="track-action-btn" data-action="visibility" title="${track.visible ? 'Hide' : 'Show'}">${track.visible ? 'üëÅ' : 'üëÅ‚Äçüó®'}</button>
                                <button class="track-action-btn" data-action="lock" title="${track.locked ? 'Unlock' : 'Lock'}">${track.locked ? 'üîí' : 'üîì'}</button>
                            </div>
                        </div>
                    `).join('')}
                `;

                // Setup track label actions
                labelsContainer.querySelectorAll('.track-action-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const trackLabel = e.target.closest('.track-label');
                        const trackId = trackLabel.dataset.trackId;
                        const track = AppState.timeline.tracks.find(t => t.id === trackId);
                        const action = e.target.dataset.action;
                        
                        if (action === 'mute') track.muted = !track.muted;
                        if (action === 'visibility') track.visible = !track.visible;
                        if (action === 'lock') track.locked = !track.locked;
                        
                        this.render();
                    });
                });

                // Render tracks
                const totalWidth = Math.max(AppState.timeline.duration * AppState.timeline.pixelsPerSecond, this.wrapper.clientWidth);
                
                this.tracksContainer.innerHTML = `
                    <div class="playhead" id="playhead" style="left: ${AppState.timeline.currentTime * AppState.timeline.pixelsPerSecond}px;"></div>
                    ${AppState.timeline.tracks.map(track => `
                        <div class="timeline-track ${track.locked ? 'locked' : ''}" data-track-id="${track.id}" style="width: ${totalWidth}px; opacity: ${track.visible ? 1 : 0.5};">
                            ${track.clips.map(clip => this.renderClip(clip, track)).join('')}
                        </div>
                    `).join('')}
                `;

                this.playhead = document.getElementById('playhead');
                this.setupClipInteractions();
            },

            renderClip(clip, track) {
                const left = clip.startTime * AppState.timeline.pixelsPerSecond;
                const width = clip.duration * AppState.timeline.pixelsPerSecond;
                const isSelected = AppState.selection.selectedClips.includes(clip.id);
                
                return `
                    <div class="timeline-clip ${clip.type} ${isSelected ? 'selected' : ''}" 
                         data-clip-id="${clip.id}" 
                         style="left: ${left}px; width: ${width}px;"
                         draggable="true">
                        ${clip.thumbnail ? `<img class="clip-thumbnail" src="${clip.thumbnail}" alt="">` : ''}
                        <span class="clip-name">${clip.name}</span>
                        <div class="clip-handle left"></div>
                        <div class="clip-handle right"></div>
                    </div>
                `;
            },

            setupClipInteractions() {
                const clips = this.tracksContainer.querySelectorAll('.timeline-clip');
                
                clips.forEach(clipEl => {
                    const clipId = clipEl.dataset.clipId;
                    
                    // Click to select
                    clipEl.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (e.ctrlKey || e.metaKey) {
                            this.toggleClipSelection(clipId);
                        } else {
                            this.selectClip(clipId);
                        }
                    });

                    // Double click to preview
                    clipEl.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        const clip = this.getClipById(clipId);
                        if (clip) {
                            this.seekTo(clip.startTime);
                            PreviewManager.previewClip(clip);
                        }
                    });

                    // Context menu
                    clipEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        this.selectClip(clipId);
                        ContextMenuManager.show(e.clientX, e.clientY);
                    });

                    // Dragging
                    let isDragging = false;
                    let startX = 0;
                    let startLeft = 0;
                    let dragType = 'move';

                    clipEl.addEventListener('mousedown', (e) => {
                        const track = this.getTrackByClipId(clipId);
                        if (track && track.locked) return;
                        
                        isDragging = true;
                        startX = e.clientX;
                        startLeft = parseFloat(clipEl.style.left);
                        
                        if (e.target.classList.contains('clip-handle')) {
                            dragType = e.target.classList.contains('left') ? 'trim-left' : 'trim-right';
                        } else {
                            dragType = 'move';
                        }
                        
                        clipEl.style.zIndex = '100';
                    });

                    document.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        
                        const deltaX = e.clientX - startX;
                        const clip = this.getClipById(clipId);
                        
                        if (dragType === 'move') {
                            let newLeft = startLeft + deltaX;
                            if (AppState.timeline.snap) {
                                newLeft = this.snapToGrid(newLeft);
                            }
                            newLeft = Math.max(0, newLeft);
                            clipEl.style.left = `${newLeft}px`;
                        } else if (dragType === 'trim-left') {
                            const currentWidth = parseFloat(clipEl.style.width);
                            let newLeft = startLeft + deltaX;
                            let newWidth = currentWidth - deltaX;
                            
                            if (newWidth >= 20 && newLeft >= 0) {
                                clipEl.style.left = `${newLeft}px`;
                                clipEl.style.width = `${newWidth}px`;
                            }
                        } else if (dragType === 'trim-right') {
                            const currentWidth = parseFloat(clipEl.style.width);
                            let newWidth = currentWidth + deltaX;
                            
                            if (newWidth >= 20) {
                                clipEl.style.width = `${newWidth}px`;
                                startX = e.clientX;
                            }
                        }
                    });

                    document.addEventListener('mouseup', () => {
                        if (!isDragging) return;
                        isDragging = false;
                        clipEl.style.zIndex = '';
                        
                        const clip = this.getClipById(clipId);
                        if (clip) {
                            const newLeft = parseFloat(clipEl.style.left);
                            const newWidth = parseFloat(clipEl.style.width);
                            
                            if (dragType === 'move') {
                                clip.startTime = newLeft / AppState.timeline.pixelsPerSecond;
                            } else if (dragType === 'trim-left') {
                                const timeDelta = (newLeft - startLeft) / AppState.timeline.pixelsPerSecond;
                                clip.startTime += timeDelta;
                                clip.inPoint += timeDelta;
                                clip.duration = newWidth / AppState.timeline.pixelsPerSecond;
                            } else if (dragType === 'trim-right') {
                                clip.duration = newWidth / AppState.timeline.pixelsPerSecond;
                                clip.outPoint = clip.inPoint + clip.duration;
                            }
                            
                            HistoryManager.saveState('Modified clip');
                            this.updateDuration();
                        }
                    });
                });
            },

            getTrackIcon(type) {
                const icons = { video: 'üé¨', audio: 'üéµ', text: '‚úèÔ∏è', effects: '‚ú®' };
                return icons[type] || 'üìÅ';
            },

            getClipById(clipId) {
                for (const track of AppState.timeline.tracks) {
                    const clip = track.clips.find(c => c.id === clipId);
                    if (clip) return clip;
                }
                return null;
            },

            getTrackByClipId(clipId) {
                for (const track of AppState.timeline.tracks) {
                    if (track.clips.find(c => c.id === clipId)) {
                        return track;
                    }
                }
                return null;
            },

            selectClip(clipId) {
                AppState.selection.selectedClips = [clipId];
                this.render();
                
                const clip = this.getClipById(clipId);
                if (clip) {
                    PropertiesManager.updateProperties(clip);
                }
            },

            toggleClipSelection(clipId) {
                const index = AppState.selection.selectedClips.indexOf(clipId);
                if (index === -1) {
                    AppState.selection.selectedClips.push(clipId);
                } else {
                    AppState.selection.selectedClips.splice(index, 1);
                }
                this.render();
            },

            clearSelection() {
                AppState.selection.selectedClips = [];
                this.render();
            },

            splitClip() {
                if (AppState.selection.selectedClips.length === 0) {
                    NotificationManager.warning('No Selection', 'Select a clip to split');
                    return;
                }

                const clipId = AppState.selection.selectedClips[0];
                const clip = this.getClipById(clipId);
                const track = this.getTrackByClipId(clipId);
                
                if (!clip || !track) return;

                const splitTime = AppState.timeline.currentTime;
                
                if (splitTime <= clip.startTime || splitTime >= clip.startTime + clip.duration) {
                    NotificationManager.warning('Invalid Split', 'Playhead must be within the clip');
                    return;
                }

                const splitPoint = splitTime - clip.startTime;
                
                // Create second half
                const newClip = {
                    ...JSON.parse(JSON.stringify(clip)),
                    id: Utils.generateId(),
                    startTime: splitTime,
                    duration: clip.duration - splitPoint,
                    inPoint: clip.inPoint + splitPoint
                };
                
                // Modify original clip
                clip.duration = splitPoint;
                clip.outPoint = clip.inPoint + splitPoint;
                
                track.clips.push(newClip);
                
                HistoryManager.saveState('Split clip');
                this.render();
                NotificationManager.success('Clip Split', 'Clip has been split at playhead');
            },

            deleteSelected() {
                if (AppState.selection.selectedClips.length === 0) {
                    NotificationManager.warning('No Selection', 'Select clips to delete');
                    return;
                }

                AppState.selection.selectedClips.forEach(clipId => {
                    for (const track of AppState.timeline.tracks) {
                        const index = track.clips.findIndex(c => c.id === clipId);
                        if (index !== -1) {
                            track.clips.splice(index, 1);
                            break;
                        }
                    }
                });

                AppState.selection.selectedClips = [];
                HistoryManager.saveState('Delete clips');
                this.render();
                this.updateDuration();
                NotificationManager.success('Deleted', 'Selected clips have been deleted');
            },

            duplicateSelected() {
                if (AppState.selection.selectedClips.length === 0) {
                    NotificationManager.warning('No Selection', 'Select clips to duplicate');
                    return;
                }

                const newClipIds = [];
                
                AppState.selection.selectedClips.forEach(clipId => {
                    const clip = this.getClipById(clipId);
                    const track = this.getTrackByClipId(clipId);
                    
                    if (clip && track) {
                        const newClip = {
                            ...JSON.parse(JSON.stringify(clip)),
                            id: Utils.generateId(),
                            startTime: clip.startTime + clip.duration
                        };
                        track.clips.push(newClip);
                        newClipIds.push(newClip.id);
                    }
                });

                AppState.selection.selectedClips = newClipIds;
                HistoryManager.saveState('Duplicate clips');
                this.render();
                this.updateDuration();
                NotificationManager.success('Duplicated', 'Clips have been duplicated');
            },

            dropMediaOnTrack(trackId, startTime) {
                const track = AppState.timeline.tracks.find(t => t.id === trackId);
                const mediaItem = AppState.ui.dragData;
                
                if (!track || !mediaItem) return;
                
                // Check if media type matches track type
                if (track.type === 'video' && (mediaItem.type === 'video' || mediaItem.type === 'image')) {
                    // OK
                } else if (track.type === 'audio' && mediaItem.type === 'audio') {
                    // OK
                } else {
                    NotificationManager.warning('Invalid Drop', 'Media type does not match track type');
                    return;
                }

                const clip = {
                    id: Utils.generateId(),
                    mediaId: mediaItem.id,
                    type: mediaItem.type,
                    name: mediaItem.name,
                    startTime: startTime,
                    duration: mediaItem.duration,
                    inPoint: 0,
                    outPoint: mediaItem.duration,
                    thumbnail: mediaItem.thumbnail,
                    url: mediaItem.url,
                    properties: {
                        x: 0,
                        y: 0,
                        scale: 100,
                        rotation: 0,
                        opacity: 100,
                        brightness: 0,
                        contrast: 0,
                        saturation: 0,
                        hue: 0,
                        speed: 100,
                        reverse: false,
                        volume: 100
                    },
                    keyframes: [],
                    filters: [],
                    effects: []
                };
                
                track.clips.push(clip);
                AppState.ui.dragData = null;
                
                HistoryManager.saveState(`Added ${mediaItem.name}`);
                this.render();
                this.updateDuration();
            },

            showAddTrackMenu() {
                const menu = document.createElement('div');
                menu.className = 'context-menu active';
                menu.style.cssText = 'top: auto; bottom: 300px; left: 150px;';
                menu.innerHTML = `
                    <div class="context-menu-item" data-type="video">üé¨ Video Track</div>
                    <div class="context-menu-item" data-type="audio">üéµ Audio Track</div>
                    <div class="context-menu-item" data-type="text">‚úèÔ∏è Text Track</div>
                    <div class="context-menu-item" data-type="effects">‚ú® Effects Track</div>
                `;
                
                document.body.appendChild(menu);
                
                menu.querySelectorAll('.context-menu-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const track = this.createTrack(item.dataset.type);
                        AppState.timeline.tracks.push(track);
                        this.render();
                        menu.remove();
                        NotificationManager.success('Track Added', `${track.name} has been added`);
                    });
                });
                
                setTimeout(() => {
                    document.addEventListener('click', function handler() {
                        menu.remove();
                        document.removeEventListener('click', handler);
                    });
                }, 100);
            },

            snapToGrid(position) {
                const snapInterval = AppState.timeline.pixelsPerSecond / 2; // Snap every 0.5 seconds
                return Math.round(position / snapInterval) * snapInterval;
            },

            seekTo(time) {
                AppState.timeline.currentTime = Utils.clamp(time, 0, AppState.timeline.duration);
                this.updatePlayhead();
                PreviewManager.render();
                document.getElementById('currentTime').textContent = Utils.formatTime(AppState.timeline.currentTime);
            },

            updatePlayhead() {
                if (this.playhead) {
                    this.playhead.style.left = `${AppState.timeline.currentTime * AppState.timeline.pixelsPerSecond}px`;
                }
            },

            updateDuration() {
                let maxEndTime = 0;
                AppState.timeline.tracks.forEach(track => {
                    track.clips.forEach(clip => {
                        const endTime = clip.startTime + clip.duration;
                        if (endTime > maxEndTime) {
                            maxEndTime = endTime;
                        }
                    });
                });
                
                AppState.timeline.duration = Math.max(maxEndTime + 30, 60);
                document.getElementById('totalTime').textContent = Utils.formatTime(maxEndTime);
                this.renderRuler();
            },

            renderRuler() {
                const canvas = this.rulerCanvas;
                const ctx = canvas.getContext('2d');
                const rect = this.wrapper.getBoundingClientRect();
                
                canvas.width = Math.max(AppState.timeline.duration * AppState.timeline.pixelsPerSecond, rect.width);
                canvas.height = 28;
                
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const pixelsPerSecond = AppState.timeline.pixelsPerSecond;
                let interval = 1;
                
                if (pixelsPerSecond < 20) interval = 10;
                else if (pixelsPerSecond < 50) interval = 5;
                else if (pixelsPerSecond < 100) interval = 2;
                
                ctx.strokeStyle = '#3a3a5a';
                ctx.fillStyle = '#888';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                
                for (let t = 0; t <= AppState.timeline.duration; t += interval) {
                    const x = t * pixelsPerSecond;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, 20);
                    ctx.lineTo(x, 28);
                    ctx.stroke();
                    
                    const label = Utils.formatTime(t).slice(3); // Remove hours
                    ctx.fillText(label, x, 14);
                }
                
                // Minor ticks
                ctx.strokeStyle = '#2a2a4a';
                const minorInterval = interval / 4;
                for (let t = 0; t <= AppState.timeline.duration; t += minorInterval) {
                    if (t % interval !== 0) {
                        const x = t * pixelsPerSecond;
                        ctx.beginPath();
                        ctx.moveTo(x, 24);
                        ctx.lineTo(x, 28);
                        ctx.stroke();
                    }
                }
            }
        };

        // ==================== PREVIEW MANAGER ====================
        const PreviewManager = {
            canvas: null,
            ctx: null,
            wrapper: null,

            init() {
                this.canvas = document.getElementById('previewCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.wrapper = document.getElementById('canvasWrapper');
                
                this.setupControls();
                this.render();
            },

            setupControls() {
                document.getElementById('playBtn').addEventListener('click', () => this.togglePlay());
                document.getElementById('prevFrameBtn').addEventListener('click', () => this.prevFrame());
                document.getElementById('nextFrameBtn').addEventListener('click', () => this.nextFrame());
                document.getElementById('stepBackBtn').addEventListener('click', () => this.stepBack());
                document.getElementById('stepForwardBtn').addEventListener('click', () => this.stepForward());
                document.getElementById('fullscreenBtn').addEventListener('click', () => this.toggleFullscreen());
                
                document.getElementById('zoomIn').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoomOut').addEventListener('click', () => this.zoomOut());
                document.getElementById('zoomFit').addEventListener('click', () => this.zoomFit());
                
                document.getElementById('aspectRatio').addEventListener('change', (e) => {
                    this.setAspectRatio(e.target.value);
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    switch(e.code) {
                        case 'Space':
                            e.preventDefault();
                            this.togglePlay();
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            if (e.shiftKey) this.prevFrame();
                            else this.stepBack();
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            if (e.shiftKey) this.nextFrame();
                            else this.stepForward();
                            break;
                        case 'Home':
                            e.preventDefault();
                            TimelineManager.seekTo(0);
                            break;
                        case 'End':
                            e.preventDefault();
                            TimelineManager.seekTo(AppState.timeline.duration);
                            break;
                        case 'KeyS':
                            if (!e.ctrlKey) {
                                e.preventDefault();
                                TimelineManager.splitClip();
                            }
                            break;
                        case 'Delete':
                        case 'Backspace':
                            e.preventDefault();
                            TimelineManager.deleteSelected();
                            break;
                        case 'KeyD':
                            if (e.ctrlKey) {
                                e.preventDefault();
                                TimelineManager.duplicateSelected();
                            }
                            break;
                        case 'KeyZ':
                            if (e.ctrlKey) {
                                e.preventDefault();
                                if (e.shiftKey) HistoryManager.redo();
                                else HistoryManager.undo();
                            }
                            break;
                        case 'KeyY':
                            if (e.ctrlKey) {
                                e.preventDefault();
                                HistoryManager.redo();
                            }
                            break;
                    }
                });
            },

            togglePlay() {
                if (AppState.playback.isPlaying) {
                    this.pause();
                } else {
                    this.play();
                }
            },

            play() {
                AppState.playback.isPlaying = true;
                document.getElementById('playBtn').innerHTML = '‚è∏';
                
                let lastTime = performance.now();
                
                const animate = (currentTime) => {
                    if (!AppState.playback.isPlaying) return;
                    
                    const deltaTime = (currentTime - lastTime) / 1000;
                    lastTime = currentTime;
                    
                    AppState.timeline.currentTime += deltaTime * AppState.playback.playbackRate;
                    
                    if (AppState.timeline.currentTime >= AppState.timeline.duration) {
                        AppState.timeline.currentTime = 0;
                    }
                    
                    TimelineManager.updatePlayhead();
                    document.getElementById('currentTime').textContent = Utils.formatTime(AppState.timeline.currentTime);
                    this.render();
                    
                    this.animationFrame = requestAnimationFrame(animate);
                };
                
                this.animationFrame = requestAnimationFrame(animate);
            },

            pause() {
                AppState.playback.isPlaying = false;
                document.getElementById('playBtn').innerHTML = '‚ñ∂';
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
            },

            prevFrame() {
                TimelineManager.seekTo(AppState.timeline.currentTime - 1/30);
            },

            nextFrame() {
                TimelineManager.seekTo(AppState.timeline.currentTime + 1/30);
            },

            stepBack() {
                TimelineManager.seekTo(AppState.timeline.currentTime - 5);
            },

            stepForward() {
                TimelineManager.seekTo(AppState.timeline.currentTime + 5);
            },

            zoomIn() {
                AppState.ui.previewZoom = Math.min(200, AppState.ui.previewZoom + 10);
                this.updateZoom();
            },

            zoomOut() {
                AppState.ui.previewZoom = Math.max(25, AppState.ui.previewZoom - 10);
                this.updateZoom();
            },

            zoomFit() {
                AppState.ui.previewZoom = 100;
                this.updateZoom();
            },

            updateZoom() {
                document.getElementById('zoomLevel').textContent = `${AppState.ui.previewZoom}%`;
                const scale = AppState.ui.previewZoom / 100;
                this.wrapper.style.transform = `scale(${scale})`;
            },

            setAspectRatio(ratio) {
                const [w, h] = ratio.split(':').map(Number);
                AppState.project.settings.aspectRatio = ratio;
                
                const baseWidth = 1280;
                const height = Math.round(baseWidth * (h / w));
                
                this.canvas.width = baseWidth;
                this.canvas.height = height;
                AppState.project.settings.width = baseWidth;
                AppState.project.settings.height = height;
                
                this.render();
            },

            toggleFullscreen() {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    this.wrapper.requestFullscreen();
                }
            },

            render() {
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Clear canvas
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width, height);
                
                // Get clips at current time
                const currentTime = AppState.timeline.currentTime;
                const clipsToRender = [];
                
                AppState.timeline.tracks.forEach(track => {
                    if (!track.visible) return;
                    
                    track.clips.forEach(clip => {
                        if (currentTime >= clip.startTime && currentTime < clip.startTime + clip.duration) {
                            clipsToRender.push({ clip, track });
                        }
                    });
                });

                // Render clips (reverse order for proper layering)
                clipsToRender.reverse().forEach(({ clip, track }) => {
                    this.renderClip(ctx, clip, width, height, currentTime);
                });

                // Render text overlays
                clipsToRender.forEach(({ clip }) => {
                    if (clip.type === 'text') {
                        this.renderText(ctx, clip, width, height, currentTime);
                    }
                });
            },

            renderClip(ctx, clip, width, height, currentTime) {
                const props = clip.properties;
                const clipTime = currentTime - clip.startTime + clip.inPoint;
                
                ctx.save();
                
                // Apply transformations
                ctx.translate(width / 2 + props.x, height / 2 + props.y);
                ctx.rotate(props.rotation * Math.PI / 180);
                ctx.scale(props.scale / 100, props.scale / 100);
                ctx.globalAlpha = props.opacity / 100;
                
                // Apply filters
                let filterStr = '';
                if (props.brightness !== 0) filterStr += `brightness(${100 + props.brightness}%) `;
                if (props.contrast !== 0) filterStr += `contrast(${100 + props.contrast}%) `;
                if (props.saturation !== 0) filterStr += `saturate(${100 + props.saturation}%) `;
                if (props.hue !== 0) filterStr += `hue-rotate(${props.hue}deg) `;
                ctx.filter = filterStr || 'none';

                // Draw placeholder content
                if (clip.type === 'video' || clip.type === 'image') {
                    const drawWidth = width;
                    const drawHeight = height;
                    
                    // Draw gradient placeholder
                    const gradient = ctx.createLinearGradient(-drawWidth/2, -drawHeight/2, drawWidth/2, drawHeight/2);
                    if (clip.type === 'video') {
                        gradient.addColorStop(0, '#1a365d');
                        gradient.addColorStop(1, '#2563eb');
                    } else {
                        gradient.addColorStop(0, '#7c2d12');
                        gradient.addColorStop(1, '#ea580c');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-drawWidth/2, -drawHeight/2, drawWidth, drawHeight);
                    
                    // Draw clip name
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(clip.name, 0, 0);
                    
                    // Draw time indicator
                    ctx.font = '16px Arial';
                    ctx.fillText(Utils.formatTime(clipTime), 0, 40);
                }
                
                ctx.restore();
            },

            renderText(ctx, clip, width, height, currentTime) {
                const props = clip.properties;
                const text = clip.text || 'Sample Text';
                
                ctx.save();
                
                ctx.translate(width / 2 + props.x, height / 2 + props.y);
                ctx.rotate(props.rotation * Math.PI / 180);
                ctx.scale(props.scale / 100, props.scale / 100);
                ctx.globalAlpha = props.opacity / 100;
                
                ctx.fillStyle = clip.textColor || '#ffffff';
                ctx.font = `${clip.textStyle || ''} ${clip.textSize || 48}px ${clip.textFont || 'Arial'}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Text shadow
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                ctx.fillText(text, 0, 0);
                
                ctx.restore();
            },

            previewClip(clip) {
                NotificationManager.info('Preview', `Previewing: ${clip.name}`);
            }
        };

        // ==================== PROPERTIES MANAGER ====================
        const PropertiesManager = {
            currentClip: null,

            init() {
                this.setupEventListeners();
            },

            setupEventListeners() {
                // Transform properties
                ['propPosX', 'propPosY'].forEach(id => {
                    document.getElementById(id).addEventListener('input', (e) => {
                        this.updateProperty(id.replace('prop', '').toLowerCase(), parseFloat(e.target.value));
                    });
                });

                // Sliders
                const sliders = [
                    { id: 'propScale', prop: 'scale', suffix: '%' },
                    { id: 'propRotation', prop: 'rotation', suffix: '¬∞' },
                    { id: 'propOpacity', prop: 'opacity', suffix: '%' },
                    { id: 'propBrightness', prop: 'brightness', suffix: '' },
                    { id: 'propContrast', prop: 'contrast', suffix: '' },
                    { id: 'propSaturation', prop: 'saturation', suffix: '' },
                    { id: 'propHue', prop: 'hue', suffix: '¬∞' },
                    { id: 'propSpeed', prop: 'speed', suffix: 'x', multiplier: 0.01 }
                ];

                sliders.forEach(({ id, prop, suffix, multiplier = 1 }) => {
                    const slider = document.getElementById(id);
                    const valueDisplay = document.getElementById(id + 'Value');
                    
                    slider.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        const displayValue = multiplier !== 1 ? (value * multiplier).toFixed(1) : value;
                        valueDisplay.textContent = `${displayValue}${suffix}`;
                        this.updateProperty(prop, value);
                    });
                });

                // Blend mode
                document.getElementById('propBlendMode').addEventListener('change', (e) => {
                    this.updateProperty('blendMode', e.target.value);
                });

                // Reverse toggle
                document.getElementById('propReverse').addEventListener('click', (e) => {
                    e.target.classList.toggle('active');
                    this.updateProperty('reverse', e.target.classList.contains('active'));
                });

                // Keyframe button
                document.getElementById('addKeyframeBtn').addEventListener('click', () => {
                    this.addKeyframe();
                });
            },

            updateProperties(clip) {
                this.currentClip = clip;
                const props = clip.properties;
                
                document.getElementById('propPosX').value = props.x || 0;
                document.getElementById('propPosY').value = props.y || 0;
                document.getElementById('propScale').value = props.scale || 100;
                document.getElementById('propScaleValue').textContent = `${props.scale || 100}%`;
                document.getElementById('propRotation').value = props.rotation || 0;
                document.getElementById('propRotationValue').textContent = `${props.rotation || 0}¬∞`;
                document.getElementById('propOpacity').value = props.opacity || 100;
                document.getElementById('propOpacityValue').textContent = `${props.opacity || 100}%`;
                document.getElementById('propBrightness').value = props.brightness || 0;
                document.getElementById('propBrightnessValue').textContent = props.brightness || 0;
                document.getElementById('propContrast').value = props.contrast || 0;
                document.getElementById('propContrastValue').textContent = props.contrast || 0;
                document.getElementById('propSaturation').value = props.saturation || 0;
                document.getElementById('propSaturationValue').textContent = props.saturation || 0;
                document.getElementById('propHue').value = props.hue || 0;
                document.getElementById('propHueValue').textContent = `${props.hue || 0}¬∞`;
                document.getElementById('propSpeed').value = props.speed || 100;
                document.getElementById('propSpeedValue').textContent = `${((props.speed || 100) * 0.01).toFixed(1)}x`;
                
                const reverseToggle = document.getElementById('propReverse');
                reverseToggle.classList.toggle('active', props.reverse || false);
            },

            updateProperty(property, value) {
                if (!this.currentClip) return;
                
                this.currentClip.properties[property] = value;
                PreviewManager.render();
            },

            addKeyframe() {
                if (!this.currentClip) {
                    NotificationManager.warning('No Selection', 'Select a clip to add keyframes');
                    return;
                }
                
                const keyframe = {
                    time: AppState.timeline.currentTime - this.currentClip.startTime,
                    properties: { ...this.currentClip.properties }
                };
                
                this.currentClip.keyframes.push(keyframe);
                this.currentClip.keyframes.sort((a, b) => a.time - b.time);
                
                NotificationManager.success('Keyframe Added', 'Keyframe added at current time');
            }
        };

        // ==================== CONTEXT MENU MANAGER ====================
        const ContextMenuManager = {
            menu: null,

            init() {
                this.menu = document.getElementById('contextMenu');
                this.setupEventListeners();
            },

            setupEventListeners() {
                // Hide on click outside
                document.addEventListener('click', () => this.hide());
                
                // Menu item actions
                this.menu.querySelectorAll('.context-menu-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const action = item.dataset.action;
                        this.executeAction(action);
                        this.hide();
                    });
                });
            },

            show(x, y) {
                this.menu.style.left = `${x}px`;
                this.menu.style.top = `${y}px`;
                this.menu.classList.add('active');
                
                // Adjust position if menu goes off screen
                const rect = this.menu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    this.menu.style.left = `${x - rect.width}px`;
                }
                if (rect.bottom > window.innerHeight) {
                    this.menu.style.top = `${y - rect.height}px`;
                }
            },

            hide() {
                this.menu.classList.remove('active');
            },

            executeAction(action) {
                switch (action) {
                    case 'cut':
                        this.cut();
                        break;
                    case 'copy':
                        this.copy();
                        break;
                    case 'paste':
                        this.paste();
                        break;
                    case 'duplicate':
                        TimelineManager.duplicateSelected();
                        break;
                    case 'split':
                        TimelineManager.splitClip();
                        break;
                    case 'delete':
                        TimelineManager.deleteSelected();
                        break;
                    case 'speed':
                        this.showSpeedDialog();
                        break;
                    case 'reverse':
                        this.reverseClip();
                        break;
                }
            },

            cut() {
                this.copy();
                TimelineManager.deleteSelected();
            },

            copy() {
                if (AppState.selection.selectedClips.length === 0) return;
                
                AppState.selection.clipboard = AppState.selection.selectedClips.map(id => {
                    const clip = TimelineManager.getClipById(id);
                    return JSON.parse(JSON.stringify(clip));
                });
                
                NotificationManager.info('Copied', `${AppState.selection.clipboard.length} clip(s) copied`);
            },

            paste() {
                if (!AppState.selection.clipboard || AppState.selection.clipboard.length === 0) {
                    NotificationManager.warning('Nothing to Paste', 'Clipboard is empty');
                    return;
                }
                
                AppState.selection.clipboard.forEach(clipData => {
                    const track = AppState.timeline.tracks.find(t => t.type === clipData.type);
                    if (track) {
                        const newClip = {
                            ...clipData,
                            id: Utils.generateId(),
                            startTime: AppState.timeline.currentTime
                        };
                        track.clips.push(newClip);
                    }
                });
                
                HistoryManager.saveState('Paste clips');
                TimelineManager.render();
                NotificationManager.success('Pasted', 'Clips pasted from clipboard');
            },

            showSpeedDialog() {
                const speed = prompt('Enter speed (0.25 - 4.0):', '1.0');
                if (speed !== null) {
                    const speedValue = parseFloat(speed);
                    if (speedValue >= 0.25 && speedValue <= 4) {
                        AppState.selection.selectedClips.forEach(id => {
                            const clip = TimelineManager.getClipById(id);
                            if (clip) {
                                clip.properties.speed = speedValue * 100;
                                clip.duration = (clip.outPoint - clip.inPoint) / speedValue;
                            }
                        });
                        HistoryManager.saveState('Change speed');
                        TimelineManager.render();
                    }
                }
            },

            reverseClip() {
                AppState.selection.selectedClips.forEach(id => {
                    const clip = TimelineManager.getClipById(id);
                    if (clip) {
                        clip.properties.reverse = !clip.properties.reverse;
                    }
                });
                HistoryManager.saveState('Reverse clips');
                NotificationManager.success('Reversed', 'Clip playback reversed');
            }
        };

        // ==================== SIDEBAR MANAGER ====================
        const SidebarManager = {
            init() {
                this.setupTabs();
                this.loadStickers();
                this.loadFilters();
                this.loadTransitions();
            },

            setupTabs() {
                document.querySelectorAll('.sidebar-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        
                        const tabName = tab.dataset.tab;
                        document.querySelectorAll('.tab-content').forEach(content => {
                            content.style.display = 'none';
                        });
                        document.getElementById(`${tabName}-tab`).style.display = 'block';
                    });
                });

                // Text templates
                document.querySelectorAll('.text-template').forEach(template => {
                    template.addEventListener('click', () => {
                        TextEditorManager.showModal(template.dataset.template);
                    });
                });

                // Sticker categories
                document.querySelectorAll('.sticker-category').forEach(cat => {
                    cat.addEventListener('click', () => {
                        document.querySelectorAll('.sticker-category').forEach(c => c.classList.remove('active'));
                        cat.classList.add('active');
                        this.loadStickers(cat.dataset.category);
                    });
                });
            },

            loadStickers(category = 'emoji') {
                const stickers = {
                    emoji: ['üòÄ', 'üòÇ', 'ü•∞', 'üòé', 'ü§î', 'üëç', '‚ù§Ô∏è', 'üî•', '‚≠ê', 'üéâ', 'üíØ', '‚ú®'],
                    shapes: ['‚¨ú', '‚¨õ', 'üî¥', 'üîµ', 'üü¢', 'üü°', 'üü†', 'üü£', '‚≠ï', '‚úñÔ∏è', '‚ûï', '‚ûñ'],
                    arrows: ['‚¨ÜÔ∏è', '‚¨áÔ∏è', '‚¨ÖÔ∏è', '‚û°Ô∏è', '‚ÜóÔ∏è', '‚ÜòÔ∏è', '‚ÜôÔ∏è', '‚ÜñÔ∏è', '‚Ü©Ô∏è', '‚Ü™Ô∏è', 'üîÑ', 'üîÉ'],
                    social: ['üë§', 'üë•', 'üí¨', '‚ù§Ô∏è', 'üëç', 'üì±', 'üíª', 'üéÆ', 'üì∑', 'üé¨', 'üéµ', 'üîî']
                };

                const grid = document.getElementById('stickerGrid');
                grid.innerHTML = stickers[category].map(sticker => `
                    <div class="sticker-item" data-sticker="${sticker}">${sticker}</div>
                `).join('');

                grid.querySelectorAll('.sticker-item').forEach(item => {
                    item.addEventListener('click', () => {
                        this.addStickerToTimeline(item.dataset.sticker);
                    });
                });
            },

            loadFilters() {
                const filters = [
                    { name: 'Normal', filter: '' },
                    { name: 'Vintage', filter: 'sepia(50%)' },
                    { name: 'B&W', filter: 'grayscale(100%)' },
                    { name: 'Warm', filter: 'sepia(30%) saturate(140%)' },
                    { name: 'Cool', filter: 'saturate(80%) hue-rotate(20deg)' },
                    { name: 'Dramatic', filter: 'contrast(130%) saturate(110%)' },
                    { name: 'Fade', filter: 'contrast(90%) brightness(110%)' },
                    { name: 'Vivid', filter: 'saturate(150%) contrast(110%)' }
                ];

                const grid = document.getElementById('filterGrid');
                grid.innerHTML = filters.map((f, i) => `
                    <div class="filter-item ${i === 0 ? 'selected' : ''}" data-filter="${f.filter}">
                        <div class="filter-preview" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); filter: ${f.filter}; width: 100%; height: 100%;"></div>
                        <div class="filter-name">${f.name}</div>
                    </div>
                `).join('');

                grid.querySelectorAll('.filter-item').forEach(item => {
                    item.addEventListener('click', () => {
                        grid.querySelectorAll('.filter-item').forEach(f => f.classList.remove('selected'));
                        item.classList.add('selected');
                        this.applyFilter(item.dataset.filter);
                    });
                });
            },

            loadTransitions() {
                const transitions = [
                    { name: 'Fade', icon: '‚óê' },
                    { name: 'Slide', icon: '‚Üí' },
                    { name: 'Zoom', icon: '‚äï' },
                    { name: 'Wipe', icon: '‚ñ¨' },
                    { name: 'Dissolve', icon: '‚óâ' },
                    { name: 'Push', icon: '‚áí' }
                ];

                const grid = document.getElementById('transitionGrid');
                grid.innerHTML = transitions.map(t => `
                    <div class="transition-item" data-transition="${t.name.toLowerCase()}">
                        <div class="transition-icon">${t.icon}</div>
                        <div class="transition-name">${t.name}</div>
                    </div>
                `).join('');

                grid.querySelectorAll('.transition-item').forEach(item => {
                    item.addEventListener('click', () => {
                        grid.querySelectorAll('.transition-item').forEach(t => t.classList.remove('selected'));
                        item.classList.add('selected');
                        NotificationManager.info('Transition', `${item.dataset.transition} transition selected`);
                    });
                });
            },

            addStickerToTimeline(sticker) {
                let track = AppState.timeline.tracks.find(t => t.type === 'text');
                if (!track) {
                    track = TimelineManager.createTrack('text');
                    AppState.timeline.tracks.push(track);
                }

                const clip = {
                    id: Utils.generateId(),
                    type: 'text',
                    name: `Sticker: ${sticker}`,
                    text: sticker,
                    startTime: AppState.timeline.currentTime,
                    duration: 3,
                    inPoint: 0,
                    outPoint: 3,
                    properties: {
                        x: 0,
                        y: 0,
                        scale: 100,
                        rotation: 0,
                        opacity: 100
                    },
                    textFont: 'Arial',
                    textSize: 72
                };

                track.clips.push(clip);
                HistoryManager.saveState('Add sticker');
                TimelineManager.render();
                NotificationManager.success('Sticker Added', `${sticker} added to timeline`);
            },

            applyFilter(filter) {
                if (AppState.selection.selectedClips.length === 0) {
                    NotificationManager.warning('No Selection', 'Select a clip to apply filter');
                    return;
                }

                AppState.selection.selectedClips.forEach(id => {
                    const clip = TimelineManager.getClipById(id);
                    if (clip) {
                        clip.filter = filter;
                    }
                });

                PreviewManager.render();
                NotificationManager.success('Filter Applied', 'Filter has been applied');
            }
        };

        // ==================== TEXT EDITOR MANAGER ====================
        const TextEditorManager = {
            modal: null,
            currentTemplate: null,

            init() {
                this.modal = document.getElementById('textModal');
                this.setupEventListeners();
            },

            setupEventListeners() {
                document.getElementById('closeTextModal').addEventListener('click', () => this.hideModal());
                document.getElementById('cancelText').addEventListener('click', () => this.hideModal());
                document.getElementById('addText').addEventListener('click', () => this.addTextToTimeline());

                // Text style buttons
                ['textBold', 'textItalic', 'textUnderline'].forEach(id => {
                    document.getElementById(id).addEventListener('click', (e) => {
                        e.target.classList.toggle('btn-primary');
                        e.target.classList.toggle('btn-ghost');
                    });
                });

                // Text size slider
                document.getElementById('textSize').addEventListener('input', (e) => {
                    document.getElementById('textSizeValue').textContent = `${e.target.value}px`;
                });

                // Color sync
                document.getElementById('textColor').addEventListener('input', (e) => {
                    document.getElementById('textColorHex').value = e.target.value;
                });
                document.getElementById('textColorHex').addEventListener('input', (e) => {
                    document.getElementById('textColor').value = e.target.value;
                });
            },

            showModal(template = 'custom') {
                this.currentTemplate = template;
                this.modal.classList.add('active');
                
                // Set defaults based on template
                const defaults = {
                    title: { size: 72, text: 'Title Text' },
                    subtitle: { size: 48, text: 'Subtitle' },
                    caption: { size: 24, text: 'Caption text' },
                    custom: { size: 48, text: '' }
                };

                const def = defaults[template] || defaults.custom;
                document.getElementById('textContent').value = def.text;
                document.getElementById('textSize').value = def.size;
                document.getElementById('textSizeValue').textContent = `${def.size}px`;
            },

            hideModal() {
                this.modal.classList.remove('active');
            },

            addTextToTimeline() {
                const text = document.getElementById('textContent').value || 'Sample Text';
                const font = document.getElementById('textFont').value;
                const size = parseInt(document.getElementById('textSize').value);
                const color = document.getElementById('textColor').value;
                const animation = document.getElementById('textAnimation').value;
                
                const isBold = document.getElementById('textBold').classList.contains('btn-primary');
                const isItalic = document.getElementById('textItalic').classList.contains('btn-primary');

                let track = AppState.timeline.tracks.find(t => t.type === 'text');
                if (!track) {
                    track = TimelineManager.createTrack('text');
                    AppState.timeline.tracks.push(track);
                }

                const clip = {
                    id: Utils.generateId(),
                    type: 'text',
                    name: text.substring(0, 20) + (text.length > 20 ? '...' : ''),
                    text: text,
                    startTime: AppState.timeline.currentTime,
                    duration: 5,
                    inPoint: 0,
                    outPoint: 5,
                    properties: {
                        x: 0,
                        y: 0,
                        scale: 100,
                        rotation: 0,
                        opacity: 100
                    },
                    textFont: font,
                    textSize: size,
                    textColor: color,
                    textStyle: `${isBold ? 'bold' : ''} ${isItalic ? 'italic' : ''}`.trim(),
                    textAnimation: animation
                };

                track.clips.push(clip);
                HistoryManager.saveState('Add text');
                TimelineManager.render();
                this.hideModal();
                NotificationManager.success('Text Added', 'Text clip added to timeline');
            }
        };

        // ==================== EXPORT MANAGER ====================
        const ExportManager = {
            modal: null,
            isExporting: false,

            init() {
                this.modal = document.getElementById('exportModal');
                this.setupEventListeners();
            },

            setupEventListeners() {
                document.getElementById('exportBtn').addEventListener('click', () => this.showModal());
                document.getElementById('closeExportModal').addEventListener('click', () => this.hideModal());
                document.getElementById('cancelExport').addEventListener('click', () => this.hideModal());
                document.getElementById('startExport').addEventListener('click', () => this.startExport());

                // Export options
                document.querySelectorAll('.export-option').forEach(option => {
                    option.addEventListener('click', () => {
                        document.querySelectorAll('.export-option').forEach(o => o.classList.remove('selected'));
                        option.classList.add('selected');
                    });
                });

                // Quality slider
                document.getElementById('exportQuality').addEventListener('input', (e) => {
                    document.getElementById('exportQualityValue').textContent = `${e.target.value}%`;
                });
            },

            showModal() {
                this.modal.classList.add('active');
            },

            hideModal() {
                if (!this.isExporting) {
                    this.modal.classList.remove('active');
                }
            },

            async startExport() {
                if (this.isExporting) return;
                
                this.isExporting = true;
                const progressDiv = document.getElementById('exportProgress');
                const progressFill = document.getElementById('exportProgressFill');
                const progressText = document.getElementById('exportProgressText');
                
                progressDiv.style.display = 'block';
                document.getElementById('startExport').disabled = true;
                
                const format = document.querySelector('.export-option.selected').dataset.format;
                const resolution = document.getElementById('exportResolution').value;
                const fps = parseInt(document.getElementById('exportFps').value);
                const quality = parseInt(document.getElementById('exportQuality').value);

                // Simulate export progress
                for (let i = 0; i <= 100; i += 2) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                    progressFill.style.width = `${i}%`;
                    
                    if (i < 20) progressText.textContent = 'Preparing timeline...';
                    else if (i < 40) progressText.textContent = 'Processing video tracks...';
                    else if (i < 60) progressText.textContent = 'Processing audio tracks...';
                    else if (i < 80) progressText.textContent = 'Applying effects...';
                    else if (i < 95) progressText.textContent = 'Encoding video...';
                    else progressText.textContent = 'Finalizing...';
                }

                // Create a demo export file
                const projectData = this.generateProjectData();
                Utils.downloadFile(
                    JSON.stringify(projectData, null, 2),
                    `${AppState.project.name}_export.json`,
                    'application/json'
                );

                progressText.textContent = 'Export complete!';
                NotificationManager.success('Export Complete', `Video exported as ${format.toUpperCase()}`);
                
                setTimeout(() => {
                    this.isExporting = false;
                    progressDiv.style.display = 'none';
                    progressFill.style.width = '0%';
                    document.getElementById('startExport').disabled = false;
                    this.hideModal();
                }, 1500);
            },

            generateProjectData() {
                return {
                    project: AppState.project,
                    timeline: {
                        tracks: AppState.timeline.tracks,
                        duration: AppState.timeline.duration
                    },
                    exportSettings: {
                        format: document.querySelector('.export-option.selected').dataset.format,
                        resolution: document.getElementById('exportResolution').value,
                        fps: document.getElementById('exportFps').value,
                        quality: document.getElementById('exportQuality').value
                    },
                    exportedAt: new Date().toISOString()
                };
            }
        };

        // ==================== PROJECT MANAGER ====================
        const ProjectManager = {
            init() {
                this.setupEventListeners();
            },

            setupEventListeners() {
                document.getElementById('saveProjectBtn').addEventListener('click', () => this.saveProject());
                document.getElementById('loadProjectBtn').addEventListener('click', () => this.loadProject());
                document.getElementById('projectInput').addEventListener('change', (e) => this.handleProjectLoad(e));

                // Auto-save every 2 minutes
                setInterval(() => this.autoSave(), 120000);
            },

            saveProject() {
                const projectData = {
                    version: '1.0.0',
                    project: AppState.project,
                    timeline: {
                        tracks: AppState.timeline.tracks,
                        duration: AppState.timeline.duration,
                        zoom: AppState.timeline.zoom
                    },
                    media: {
                        files: AppState.media.files.map(f => ({
                            id: f.id,
                            type: f.type,
                            name: f.name,
                            duration: f.duration
                        })),
                        audioFiles: AppState.media.audioFiles
                    },
                    savedAt: new Date().toISOString()
                };

                const fileName = `${AppState.project.name.replace(/\s+/g, '_')}_${Date.now()}.capcut`;
                Utils.downloadFile(
                    JSON.stringify(projectData, null, 2),
                    fileName,
                    'application/json'
                );

                NotificationManager.success('Project Saved', `Saved as ${fileName}`);
            },

            loadProject() {
                document.getElementById('projectInput').click();
            },

            handleProjectLoad(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const projectData = JSON.parse(event.target.result);
                        this.applyProjectData(projectData);
                        NotificationManager.success('Project Loaded', `Loaded: ${projectData.project.name}`);
                    } catch (error) {
                        NotificationManager.error('Load Error', 'Failed to load project file');
                        console.error('Project load error:', error);
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            },

            applyProjectData(data) {
                if (data.project) {
                    AppState.project = { ...AppState.project, ...data.project };
                }
                
                if (data.timeline) {
                    AppState.timeline.tracks = data.timeline.tracks || [];
                    AppState.timeline.duration = data.timeline.duration || 300;
                    AppState.timeline.zoom = data.timeline.zoom || 50;
                }

                // Clear history for loaded project
                AppState.history.undoStack = [];
                AppState.history.redoStack = [];
                
                TimelineManager.render();
                TimelineManager.renderRuler();
                PreviewManager.render();
                HistoryManager.updateButtons();
            },

            autoSave() {
                const autoSaveData = {
                    project: AppState.project,
                    timeline: AppState.timeline,
                    timestamp: new Date().toISOString()
                };
                
                try {
                    localStorage.setItem('capcut_autosave', JSON.stringify(autoSaveData));
                    console.log('Auto-saved project');
                } catch (error) {
                    console.warn('Auto-save failed:', error);
                }
            },

            loadAutoSave() {
                try {
                    const savedData = localStorage.getItem('capcut_autosave');
                    if (savedData) {
                        const data = JSON.parse(savedData);
                        const savedTime = new Date(data.timestamp);
                        const now = new Date();
                        const hoursSinceSave = (now - savedTime) / (1000 * 60 * 60);
                        
                        if (hoursSinceSave < 24) {
                            if (confirm('Found an auto-saved project. Would you like to restore it?')) {
                                this.applyProjectData(data);
                                NotificationManager.info('Restored', 'Auto-saved project restored');
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Failed to load auto-save:', error);
                }
            }
        };

        // ==================== EFFECTS ENGINE ====================
        const EffectsEngine = {
            effects: {
                blur: {
                    name: 'Blur',
                    apply: (ctx, params) => {
                        ctx.filter = `blur(${params.amount || 5}px)`;
                    }
                },
                glow: {
                    name: 'Glow',
                    apply: (ctx, params) => {
                        ctx.shadowColor = params.color || '#ffffff';
                        ctx.shadowBlur = params.amount || 20;
                    }
                },
                vignette: {
                    name: 'Vignette',
                    apply: (ctx, canvas, params) => {
                        const gradient = ctx.createRadialGradient(
                            canvas.width / 2, canvas.height / 2, 0,
                            canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 2
                        );
                        gradient.addColorStop(0, 'rgba(0,0,0,0)');
                        gradient.addColorStop(1, `rgba(0,0,0,${params.amount || 0.5})`);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                },
                chromatic: {
                    name: 'Chromatic Aberration',
                    apply: (ctx, canvas, params) => {
                        const amount = params.amount || 3;
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        // Simplified chromatic aberration
                        ctx.globalCompositeOperation = 'screen';
                        ctx.fillStyle = `rgba(255,0,0,0.1)`;
                        ctx.fillRect(amount, 0, canvas.width, canvas.height);
                        ctx.fillStyle = `rgba(0,0,255,0.1)`;
                        ctx.fillRect(-amount, 0, canvas.width, canvas.height);
                        ctx.globalCompositeOperation = 'source-over';
                    }
                },
                grain: {
                    name: 'Film Grain',
                    apply: (ctx, canvas, params) => {
                        const amount = params.amount || 0.1;
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        for (let i = 0; i < data.length; i += 4) {
                            const noise = (Math.random() - 0.5) * amount * 255;
                            data[i] += noise;
                            data[i + 1] += noise;
                            data[i + 2] += noise;
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                    }
                },
                glitch: {
                    name: 'Glitch',
                    apply: (ctx, canvas, params) => {
                        const slices = params.slices || 5;
                        const maxOffset = params.amount || 20;
                        const sliceHeight = canvas.height / slices;
                        
                        for (let i = 0; i < slices; i++) {
                            if (Math.random() > 0.5) {
                                const offset = (Math.random() - 0.5) * maxOffset;
                                const y = i * sliceHeight;
                                const imageData = ctx.getImageData(0, y, canvas.width, sliceHeight);
                                ctx.putImageData(imageData, offset, y);
                            }
                        }
                    }
                }
            },

            applyEffect(ctx, canvas, effectName, params = {}) {
                const effect = this.effects[effectName];
                if (effect) {
                    effect.apply(ctx, canvas, params);
                }
            },

            getEffectsList() {
                return Object.keys(this.effects).map(key => ({
                    id: key,
                    name: this.effects[key].name
                }));
            }
        };

        // ==================== TRANSITIONS ENGINE ====================
        const TransitionsEngine = {
            transitions: {
                fade: {
                    name: 'Fade',
                    apply: (ctx, clipA, clipB, progress, width, height) => {
                        ctx.globalAlpha = 1 - progress;
                        // Draw clipA
                        ctx.globalAlpha = progress;
                        // Draw clipB
                        ctx.globalAlpha = 1;
                    }
                },
                slideLeft: {
                    name: 'Slide Left',
                    apply: (ctx, clipA, clipB, progress, width, height) => {
                        const offset = width * progress;
                        // Draw clipA at -offset
                        // Draw clipB at width - offset
                    }
                },
                slideRight: {
                    name: 'Slide Right',
                    apply: (ctx, clipA, clipB, progress, width, height) => {
                        const offset = width * progress;
                        // Draw clipA at offset
                        // Draw clipB at -width + offset
                    }
                },
                zoom: {
                    name: 'Zoom',
                    apply: (ctx, clipA, clipB, progress, width, height) => {
                        const scale = 1 + progress;
                        ctx.globalAlpha = 1 - progress;
                        ctx.scale(scale, scale);
                        // Draw clipA
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.globalAlpha = progress;
                        // Draw clipB
                        ctx.globalAlpha = 1;
                    }
                },
                wipeLeft: {
                    name: 'Wipe Left',
                    apply: (ctx, clipA, clipB, progress, width, height) => {
                        const wipeX = width * (1 - progress);
                        // Draw clipA
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, 0, wipeX, height);
                        ctx.clip();
                        // Draw clipB
                        ctx.restore();
                    }
                },
                dissolve: {
                    name: 'Dissolve',
                    apply: (ctx, clipA, clipB, progress, width, height) => {
                        // More complex pixel-based dissolve
                        ctx.globalAlpha = 1 - progress;
                        // Draw clipA
                        ctx.globalAlpha = progress;
                        // Draw clipB with noise pattern
                        ctx.globalAlpha = 1;
                    }
                }
            },

            applyTransition(ctx, transitionName, clipA, clipB, progress, width, height) {
                const transition = this.transitions[transitionName];
                if (transition) {
                    transition.apply(ctx, clipA, clipB, progress, width, height);
                }
            },

            getTransitionsList() {
                return Object.keys(this.transitions).map(key => ({
                    id: key,
                    name: this.transitions[key].name
                }));
            }
        };

        // ==================== ANIMATION ENGINE ====================
        const AnimationEngine = {
            easings: {
                linear: t => t,
                easeIn: t => t * t,
                easeOut: t => t * (2 - t),
                easeInOut: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
                easeInCubic: t => t * t * t,
                easeOutCubic: t => (--t) * t * t + 1,
                easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
                bounce: t => {
                    if (t < 1/2.75) return 7.5625 * t * t;
                    if (t < 2/2.75) return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
                    if (t < 2.5/2.75) return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
                    return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
                },
                elastic: t => {
                    if (t === 0 || t === 1) return t;
                    return Math.pow(2, -10 * t) * Math.sin((t - 0.1) * 5 * Math.PI) + 1;
                }
            },

            textAnimations: {
                none: {
                    name: 'None',
                    apply: (ctx, text, progress, x, y, props) => {
                        ctx.fillText(text, x, y);
                    }
                },
                fadeIn: {
                    name: 'Fade In',
                    apply: (ctx, text, progress, x, y, props) => {
                        ctx.globalAlpha = this.easings.easeOut(Math.min(progress * 3, 1));
                        ctx.fillText(text, x, y);
                        ctx.globalAlpha = 1;
                    }
                },
                slideUp: {
                    name: 'Slide Up',
                    apply: (ctx, text, progress, x, y, props) => {
                        const offset = (1 - this.easings.easeOut(Math.min(progress * 3, 1))) * 50;
                        ctx.globalAlpha = this.easings.easeOut(Math.min(progress * 3, 1));
                        ctx.fillText(text, x, y + offset);
                        ctx.globalAlpha = 1;
                    }
                },
                slideDown: {
                    name: 'Slide Down',
                    apply: (ctx, text, progress, x, y, props) => {
                        const offset = (1 - this.easings.easeOut(Math.min(progress * 3, 1))) * -50;
                        ctx.globalAlpha = this.easings.easeOut(Math.min(progress * 3, 1));
                        ctx.fillText(text, x, y + offset);
                        ctx.globalAlpha = 1;
                    }
                },
                typewriter: {
                    name: 'Typewriter',
                    apply: (ctx, text, progress, x, y, props) => {
                        const chars = Math.floor(text.length * Math.min(progress * 2, 1));
                        ctx.fillText(text.substring(0, chars), x, y);
                    }
                },
                bounce: {
                    name: 'Bounce',
                    apply: (ctx, text, progress, x, y, props) => {
                        const scale = this.easings.bounce(Math.min(progress * 2, 1));
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.scale(scale, scale);
                        ctx.fillText(text, 0, 0);
                        ctx.restore();
                    }
                },
                zoom: {
                    name: 'Zoom',
                    apply: (ctx, text, progress, x, y, props) => {
                        const scale = this.easings.easeOut(Math.min(progress * 2, 1));
                        ctx.globalAlpha = scale;
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.scale(scale, scale);
                        ctx.fillText(text, 0, 0);
                        ctx.restore();
                        ctx.globalAlpha = 1;
                    }
                }
            },

            interpolateKeyframes(keyframes, time, property) {
                if (!keyframes || keyframes.length === 0) return null;
                
                // Find surrounding keyframes
                let prevKeyframe = null;
                let nextKeyframe = null;
                
                for (const kf of keyframes) {
                    if (kf.time <= time) {
                        prevKeyframe = kf;
                    } else if (!nextKeyframe) {
                        nextKeyframe = kf;
                        break;
                    }
                }
                
                if (!prevKeyframe && !nextKeyframe) return null;
                if (!prevKeyframe) return nextKeyframe.properties[property];
                if (!nextKeyframe) return prevKeyframe.properties[property];
                
                // Interpolate
                const t = (time - prevKeyframe.time) / (nextKeyframe.time - prevKeyframe.time);
                const easedT = this.easings.easeInOut(t);
                
                const startValue = prevKeyframe.properties[property];
                const endValue = nextKeyframe.properties[property];
                
                return Utils.lerp(startValue, endValue, easedT);
            },

            applyTextAnimation(ctx, animationName, text, progress, x, y, props) {
                const animation = this.textAnimations[animationName] || this.textAnimations.none;
                animation.apply.call(this, ctx, text, progress, x, y, props);
            }
        };

        // ==================== AUDIO ENGINE ====================
        const AudioEngine = {
            audioContext: null,
            masterGain: null,
            tracks: new Map(),

            init() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.audioContext.createGain();
                this.masterGain.connect(this.audioContext.destination);
            },

            async loadAudio(url, clipId) {
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    this.tracks.set(clipId, audioBuffer);
                    return audioBuffer;
                } catch (error) {
                    console.error('Failed to load audio:', error);
                    return null;
                }
            },

            playClip(clipId, startTime = 0, volume = 1) {
                const buffer = this.tracks.get(clipId);
                if (!buffer) return null;

                const source = this.audioContext.createBufferSource();
                const gainNode = this.audioContext.createGain();
                
                source.buffer = buffer;
                gainNode.gain.value = volume;
                
                source.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                source.start(0, startTime);
                return { source, gainNode };
            },

            setMasterVolume(volume) {
                this.masterGain.gain.value = Utils.clamp(volume, 0, 1);
            },

            generateWaveform(audioBuffer, width, height) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                
                const data = audioBuffer.getChannelData(0);
                const step = Math.ceil(data.length / width);
                const amp = height / 2;
                
                ctx.fillStyle = '#22c55e';
                
                for (let i = 0; i < width; i++) {
                    let min = 1.0;
                    let max = -1.0;
                    
                    for (let j = 0; j < step; j++) {
                        const datum = data[(i * step) + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    
                    ctx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
                }
                
                return canvas.toDataURL();
            },

            applyAudioEffect(effectName, params) {
                switch (effectName) {
                    case 'fadeIn':
                        return this.createFadeIn(params.duration);
                    case 'fadeOut':
                        return this.createFadeOut(params.duration);
                    case 'reverb':
                        return this.createReverb(params.decay);
                    case 'delay':
                        return this.createDelay(params.time, params.feedback);
                    default:
                        return null;
                }
            },

            createFadeIn(duration) {
                const gainNode = this.audioContext.createGain();
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(1, this.audioContext.currentTime + duration);
                return gainNode;
            },

            createFadeOut(duration) {
                const gainNode = this.audioContext.createGain();
                gainNode.gain.setValueAtTime(1, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + duration);
                return gainNode;
            },

            createReverb(decay = 2) {
                const convolver = this.audioContext.createConvolver();
                const rate = this.audioContext.sampleRate;
                const length = rate * decay;
                const impulse = this.audioContext.createBuffer(2, length, rate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
                    }
                }
                
                convolver.buffer = impulse;
                return convolver;
            },

            createDelay(time = 0.5, feedback = 0.5) {
                const delay = this.audioContext.createDelay();
                const feedbackGain = this.audioContext.createGain();
                
                delay.delayTime.value = time;
                feedbackGain.gain.value = feedback;
                
                delay.connect(feedbackGain);
                feedbackGain.connect(delay);
                
                return delay;
            }
        };

        // ==================== COLOR GRADING ENGINE ====================
        const ColorGradingEngine = {
            luts: {
                cinematic: {
                    name: 'Cinematic',
                    adjustments: { contrast: 20, saturation: -10, shadows: -15, highlights: 10 }
                },
                vintage: {
                    name: 'Vintage',
                    adjustments: { contrast: -10, saturation: -30, warmth: 20, fade: 15 }
                },
                coldBlue: {
                    name: 'Cold Blue',
                    adjustments: { temperature: -30, tint: 10, contrast: 15 }
                },
                warmSunset: {
                    name: 'Warm Sunset',
                    adjustments: { temperature: 40, saturation: 20, contrast: 10 }
                },
                blackAndWhite: {
                    name: 'Black & White',
                    adjustments: { saturation: -100, contrast: 20 }
                },
                sepia: {
                    name: 'Sepia',
                    adjustments: { saturation: -50, warmth: 40, contrast: 10 }
                }
            },

            applyColorGrade(ctx, canvas, gradeName) {
                const grade = this.luts[gradeName];
                if (!grade) return;

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const adj = grade.adjustments;

                for (let i = 0; i < data.length; i += 4) {
                    let r = data[i];
                    let g = data[i + 1];
                    let b = data[i + 2];

                    // Apply adjustments
                    if (adj.contrast) {
                        const factor = (259 * (adj.contrast + 255)) / (255 * (259 - adj.contrast));
                        r = factor * (r - 128) + 128;
                        g = factor * (g - 128) + 128;
                        b = factor * (b - 128) + 128;
                    }

                    if (adj.saturation) {
                        const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
                        const satFactor = 1 + adj.saturation / 100;
                        r = gray + satFactor * (r - gray);
                        g = gray + satFactor * (g - gray);
                        b = gray + satFactor * (b - gray);
                    }

                    if (adj.temperature || adj.warmth) {
                        const temp = (adj.temperature || adj.warmth || 0) / 100;
                        r += temp * 30;
                        b -= temp * 30;
                    }

                    data[i] = Utils.clamp(r, 0, 255);
                    data[i + 1] = Utils.clamp(g, 0, 255);
                    data[i + 2] = Utils.clamp(b, 0, 255);
                }

                ctx.putImageData(imageData, 0, 0);
            },

            adjustColorChannels(imageData, rMult, gMult, bMult) {
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Utils.clamp(data[i] * rMult, 0, 255);
                    data[i + 1] = Utils.clamp(data[i + 1] * gMult, 0, 255);
                    data[i + 2] = Utils.clamp(data[i + 2] * bMult, 0, 255);
                }
                return imageData;
            },

            applyToneCurve(imageData, curve) {
                const data = imageData.data;
                const lookupTable = this.generateLookupTable(curve);
                
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = lookupTable[data[i]];
                    data[i + 1] = lookupTable[data[i + 1]];
                    data[i + 2] = lookupTable[data[i + 2]];
                }
                return imageData;
            },

            generateLookupTable(curve) {
                const table = new Uint8Array(256);
                for (let i = 0; i < 256; i++) {
                    table[i] = Utils.clamp(Math.round(this.evaluateCurve(curve, i / 255) * 255), 0, 255);
                }
                return table;
            },

            evaluateCurve(curve, x) {
                // Simple bezier curve evaluation
                return curve.reduce((acc, point, i) => {
                    const t = x;
                    const binomial = this.binomialCoefficient(curve.length - 1, i);
                    const term = binomial * Math.pow(1 - t, curve.length - 1 - i) * Math.pow(t, i);
                    return acc + term * point.y;
                }, 0);
            },

            binomialCoefficient(n, k) {
                let result = 1;
                for (let i = 0; i < k; i++) {
                    result *= (n - i) / (i + 1);
                }
                return result;
            }
        };

        // ==================== VIDEO RENDERER ====================
        const VideoRenderer = {
            offscreenCanvas: null,
            offscreenCtx: null,

            init() {
                this.offscreenCanvas = document.createElement('canvas');
                this.offscreenCtx = this.offscreenCanvas.getContext('2d');
            },

            async renderFrame(time, width, height) {
                this.offscreenCanvas.width = width;
                this.offscreenCanvas.height = height;
                const ctx = this.offscreenCtx;

                // Clear
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width, height);

                // Get active clips
                const activeClips = this.getActiveClips(time);

                // Render each clip
                for (const { clip, track } of activeClips) {
                    await this.renderClip(ctx, clip, time, width, height);
                }

                return this.offscreenCanvas;
            },

            getActiveClips(time) {
                const clips = [];
                
                // Iterate tracks in reverse for proper z-order
                for (let i = AppState.timeline.tracks.length - 1; i >= 0; i--) {
                    const track = AppState.timeline.tracks[i];
                    if (!track.visible) continue;

                    for (const clip of track.clips) {
                        if (time >= clip.startTime && time < clip.startTime + clip.duration) {
                            clips.push({ clip, track });
                        }
                    }
                }

                return clips;
            },

            async renderClip(ctx, clip, time, width, height) {
                const localTime = time - clip.startTime;
                const progress = localTime / clip.duration;
                const props = clip.properties;

                // Apply keyframe interpolation
                const animatedProps = this.interpolateProperties(clip, localTime);
                const finalProps = { ...props, ...animatedProps };

                ctx.save();

                // Transform
                ctx.translate(width / 2 + finalProps.x, height / 2 + finalProps.y);
                ctx.rotate((finalProps.rotation || 0) * Math.PI / 180);
                ctx.scale((finalProps.scale || 100) / 100, (finalProps.scale || 100) / 100);
                ctx.globalAlpha = (finalProps.opacity || 100) / 100;

                // Apply filters
                ctx.filter = this.buildFilterString(finalProps);

                // Render based on type
                switch (clip.type) {
                    case 'video':
                    case 'image':
                        this.renderMediaClip(ctx, clip, width, height, localTime);
                        break;
                    case 'text':
                        this.renderTextClip(ctx, clip, width, height, progress);
                        break;
                }

                // Apply effects
                if (clip.effects && clip.effects.length > 0) {
                    for (const effect of clip.effects) {
                        EffectsEngine.applyEffect(ctx, this.offscreenCanvas, effect.type, effect.params);
                    }
                }

                ctx.restore();
            },

            renderMediaClip(ctx, clip, width, height, localTime) {
                // For demo, render a gradient placeholder
                const gradient = ctx.createLinearGradient(-width/2, -height/2, width/2, height/2);
                
                if (clip.type === 'video') {
                    gradient.addColorStop(0, '#1e3a5f');
                    gradient.addColorStop(1, '#3b82f6');
                } else {
                    gradient.addColorStop(0, '#7c2d12');
                    gradient.addColorStop(1, '#f59e0b');
                }

                ctx.fillStyle = gradient;
                ctx.fillRect(-width/2, -height/2, width, height);

                // Clip info
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(clip.name, 0, 0);
            },

            renderTextClip(ctx, clip, width, height, progress) {
                const text = clip.text || 'Text';
                
                ctx.fillStyle = clip.textColor || '#ffffff';
                ctx.font = `${clip.textStyle || ''} ${clip.textSize || 48}px ${clip.textFont || 'Arial'}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Text shadow
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                // Apply animation
                if (clip.textAnimation && clip.textAnimation !== 'none') {
                    AnimationEngine.applyTextAnimation(ctx, clip.textAnimation, text, progress, 0, 0, clip);
                } else {
                    ctx.fillText(text, 0, 0);
                }
            },

            interpolateProperties(clip, localTime) {
                if (!clip.keyframes || clip.keyframes.length < 2) return {};

                const animated = {};
                const properties = ['x', 'y', 'scale', 'rotation', 'opacity'];

                for (const prop of properties) {
                    const value = AnimationEngine.interpolateKeyframes(clip.keyframes, localTime, prop);
                    if (value !== null) {
                        animated[prop] = value;
                    }
                }

                return animated;
            },

            buildFilterString(props) {
                const filters = [];
                
                if (props.brightness && props.brightness !== 0) {
                    filters.push(`brightness(${100 + props.brightness}%)`);
                }
                if (props.contrast && props.contrast !== 0) {
                    filters.push(`contrast(${100 + props.contrast}%)`);
                }
                if (props.saturation && props.saturation !== 0) {
                    filters.push(`saturate(${100 + props.saturation}%)`);
                }
                if (props.hue && props.hue !== 0) {
                    filters.push(`hue-rotate(${props.hue}deg)`);
                }
                if (props.blur && props.blur > 0) {
                    filters.push(`blur(${props.blur}px)`);
                }

                return filters.length > 0 ? filters.join(' ') : 'none';
            }
        };

        // ==================== EXPORT RENDERER ====================
        const ExportRenderer = {
            async exportToVideo(options = {}) {
                const {
                    format = 'webm',
                    width = 1920,
                    height = 1080,
                    fps = 30,
                    quality = 0.8,
                    onProgress = () => {}
                } = options;

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // Calculate total frames
                let totalDuration = 0;
                AppState.timeline.tracks.forEach(track => {
                    track.clips.forEach(clip => {
                        const endTime = clip.startTime + clip.duration;
                        if (endTime > totalDuration) totalDuration = endTime;
                    });
                });

                const totalFrames = Math.ceil(totalDuration * fps);
                const frames = [];

                // Render each frame
                for (let frame = 0; frame < totalFrames; frame++) {
                    const time = frame / fps;
                    
                    // Clear canvas
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, width, height);

                    // Render frame
                    const renderedFrame = await VideoRenderer.renderFrame(time, width, height);
                    ctx.drawImage(renderedFrame, 0, 0, width, height);

                    // Store frame data
                    frames.push(canvas.toDataURL('image/webp', quality));

                    onProgress(frame / totalFrames);
                }

                onProgress(1);
                return frames;
            },

            async exportToGif(options = {}) {
                const {
                    width = 480,
                    height = 270,
                    fps = 10,
                    quality = 10,
                    onProgress = () => {}
                } = options;

                // Simplified GIF export - would need a GIF encoder library for actual export
                NotificationManager.info('GIF Export', 'GIF export requires additional library support');
                return null;
            },

            async exportFrameSequence(options = {}) {
                const frames = await this.exportToVideo({
                    ...options,
                    onProgress: options.onProgress
                });

                // Return array of frame data URLs
                return frames;
            }
        };

        // ==================== SHORTCUTS MANAGER ====================
        const ShortcutsManager = {
            shortcuts: {
                'Space': { action: 'togglePlay', description: 'Play/Pause' },
                'KeyS': { action: 'split', description: 'Split clip at playhead' },
                'Delete': { action: 'delete', description: 'Delete selected' },
                'Backspace': { action: 'delete', description: 'Delete selected' },
                'KeyC+ctrl': { action: 'copy', description: 'Copy' },
                'KeyX+ctrl': { action: 'cut', description: 'Cut' },
                'KeyV+ctrl': { action: 'paste', description: 'Paste' },
                'KeyD+ctrl': { action: 'duplicate', description: 'Duplicate' },
                'KeyZ+ctrl': { action: 'undo', description: 'Undo' },
                'KeyY+ctrl': { action: 'redo', description: 'Redo' },
                'KeyZ+ctrl+shift': { action: 'redo', description: 'Redo' },
                'KeyS+ctrl': { action: 'save', description: 'Save project' },
                'KeyO+ctrl': { action: 'open', description: 'Open project' },
                'KeyE+ctrl': { action: 'export', description: 'Export' },
                'ArrowLeft': { action: 'stepBack', description: 'Step backward' },
                'ArrowRight': { action: 'stepForward', description: 'Step forward' },
                'ArrowLeft+shift': { action: 'prevFrame', description: 'Previous frame' },
                'ArrowRight+shift': { action: 'nextFrame', description: 'Next frame' },
                'Home': { action: 'goToStart', description: 'Go to start' },
                'End': { action: 'goToEnd', description: 'Go to end' },
                'KeyA+ctrl': { action: 'selectAll', description: 'Select all clips' },
                'Escape': { action: 'deselect', description: 'Deselect all' },
                'Equal+ctrl': { action: 'zoomIn', description: 'Zoom in timeline' },
                'Minus+ctrl': { action: 'zoomOut', description: 'Zoom out timeline' },
                'Digit0+ctrl': { action: 'zoomFit', description: 'Fit timeline to view' }
            },

            init() {
                document.addEventListener('keydown', (e) => this.handleKeydown(e));
            },

            handleKeydown(e) {
                // Ignore if typing in input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                let shortcutKey = e.code;
                if (e.ctrlKey || e.metaKey) shortcutKey += '+ctrl';
                if (e.shiftKey) shortcutKey += '+shift';
                if (e.altKey) shortcutKey += '+alt';

                const shortcut = this.shortcuts[shortcutKey];
                if (shortcut) {
                    e.preventDefault();
                    this.executeAction(shortcut.action);
                }
            },

            executeAction(action) {
                switch (action) {
                    case 'togglePlay':
                        PreviewManager.togglePlay();
                        break;
                    case 'split':
                        TimelineManager.splitClip();
                        break;
                    case 'delete':
                        TimelineManager.deleteSelected();
                        break;
                    case 'copy':
                        ContextMenuManager.copy();
                        break;
                    case 'cut':
                        ContextMenuManager.cut();
                        break;
                    case 'paste':
                        ContextMenuManager.paste();
                        break;
                    case 'duplicate':
                        TimelineManager.duplicateSelected();
                        break;
                    case 'undo':
                        HistoryManager.undo();
                        break;
                    case 'redo':
                        HistoryManager.redo();
                        break;
                    case 'save':
                        ProjectManager.saveProject();
                        break;
                    case 'open':
                        ProjectManager.loadProject();
                        break;
                    case 'export':
                        ExportManager.showModal();
                        break;
                    case 'stepBack':
                        PreviewManager.stepBack();
                        break;
                    case 'stepForward':
                        PreviewManager.stepForward();
                        break;
                    case 'prevFrame':
                        PreviewManager.prevFrame();
                        break;
                    case 'nextFrame':
                        PreviewManager.nextFrame();
                        break;
                    case 'goToStart':
                        TimelineManager.seekTo(0);
                        break;
                    case 'goToEnd':
                        TimelineManager.seekTo(AppState.timeline.duration);
                        break;
                    case 'selectAll':
                        this.selectAllClips();
                        break;
                    case 'deselect':
                        TimelineManager.clearSelection();
                        break;
                    case 'zoomIn':
                        this.zoomTimeline(10);
                        break;
                    case 'zoomOut':
                        this.zoomTimeline(-10);
                        break;
                    case 'zoomFit':
                        this.fitTimeline();
                        break;
                }
            },

            selectAllClips() {
                AppState.selection.selectedClips = [];
                AppState.timeline.tracks.forEach(track => {
                    track.clips.forEach(clip => {
                        AppState.selection.selectedClips.push(clip.id);
                    });
                });
                TimelineManager.render();
            },

            zoomTimeline(delta) {
                const newZoom = Utils.clamp(AppState.timeline.zoom + delta, 10, 200);
                AppState.timeline.zoom = newZoom;
                AppState.timeline.pixelsPerSecond = newZoom;
                document.getElementById('timelineZoom').value = newZoom;
                document.getElementById('timelineZoomValue').textContent = `${newZoom}%`;
                TimelineManager.render();
                TimelineManager.renderRuler();
            },

            fitTimeline() {
                const wrapper = document.getElementById('timelineWrapper');
                const wrapperWidth = wrapper.clientWidth;
                let maxEndTime = 0;

                AppState.timeline.tracks.forEach(track => {
                    track.clips.forEach(clip => {
                        const endTime = clip.startTime + clip.duration;
                        if (endTime > maxEndTime) maxEndTime = endTime;
                    });
                });

                if (maxEndTime > 0) {
                    const zoom = Math.floor((wrapperWidth / maxEndTime) * 0.9);
                    this.zoomTimeline(zoom - AppState.timeline.zoom);
                }
            }
        };

        // ==================== DRAG AND DROP MANAGER ====================
        const DragDropManager = {
            init() {
                // Prevent default drag behavior on document
                document.addEventListener('dragover', (e) => e.preventDefault());
                document.addEventListener('drop', (e) => e.preventDefault());

                // Setup drop zone for entire app
                const appContainer = document.querySelector('.app-container');
                
                appContainer.addEventListener('dragenter', (e) => {
                    if (e.dataTransfer.types.includes('Files')) {
                        this.showDropOverlay();
                    }
                });

                appContainer.addEventListener('dragleave', (e) => {
                    if (e.target === appContainer || !appContainer.contains(e.relatedTarget)) {
                        this.hideDropOverlay();
                    }
                });

                appContainer.addEventListener('drop', (e) => {
                    this.hideDropOverlay();
                    if (e.dataTransfer.files.length > 0) {
                        MediaManager.handleFiles(e.dataTransfer.files);
                    }
                });
            },

            showDropOverlay() {
                let overlay = document.getElementById('dropOverlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'dropOverlay';
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(233, 69, 96, 0.1);
                        border: 4px dashed var(--accent-primary);
                        z-index: 9999;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        pointer-events: none;
                    `;
                    overlay.innerHTML = `
                        <div style="text-align: center; color: var(--accent-primary);">
                            <div style="font-size: 64px; margin-bottom: 16px;">üì•</div>
                            <div style="font-size: 24px; font-weight: bold;">Drop files to import</div>
                            <div style="font-size: 14px; margin-top: 8px; color: var(--text-secondary);">
                                Videos, Images, or Audio files
                            </div>
                        </div>
                    `;
                    document.body.appendChild(overlay);
                }
                overlay.style.display = 'flex';
            },

            hideDropOverlay() {
                const overlay = document.getElementById('dropOverlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
            }
        };

        // ==================== RESIZE MANAGER ====================
        const ResizeManager = {
            init() {
                window.addEventListener('resize', Utils.debounce(() => {
                    this.handleResize();
                }, 250));

                this.handleResize();
            },

            handleResize() {
                // Update ruler canvas size
                TimelineManager.renderRuler();
                
                // Update preview zoom
                PreviewManager.zoomFit();
                
                // Re-render timeline
                TimelineManager.render();
            }
        };

        // ==================== PERFORMANCE MONITOR ====================
        const PerformanceMonitor = {
            frameCount: 0,
            lastTime: performance.now(),
            fps: 0,
            enabled: false,

            init() {
                if (this.enabled) {
                    this.createDisplay();
                    this.update();
                }
            },

            createDisplay() {
                const display = document.createElement('div');
                display.id = 'fpsDisplay';
                display.style.cssText = `
                    position: fixed;
                    top: 60px;
                    left: 10px;
                    background: rgba(0,0,0,0.7);
                    color: #0f0;
                    padding: 4px 8px;
                    font-family: monospace;
                    font-size: 12px;
                    border-radius: 4px;
                    z-index: 10000;
                `;
                document.body.appendChild(display);
            },

            update() {
                this.frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - this.lastTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                    
                    const display = document.getElementById('fpsDisplay');
                    if (display) {
                        display.textContent = `FPS: ${this.fps}`;
                        display.style.color = this.fps >= 30 ? '#0f0' : this.fps >= 15 ? '#ff0' : '#f00';
                    }
                }
                
                requestAnimationFrame(() => this.update());
            }
        };

        // ==================== TOUR / ONBOARDING ====================
        const TourManager = {
            steps: [
                {
                    target: '.sidebar-left',
                    title: 'Media Library',
                    description: 'Upload and manage your media files here. Drag them to the timeline to add.'
                },
                {
                    target: '.preview-container',
                    title: 'Preview Window',
                    description: 'Preview your video edits in real-time. Use playback controls to navigate.'
                },
                {
                    target: '.sidebar-right',
                    title: 'Properties Panel',
                    description: 'Adjust properties of selected clips including transform, color, and effects.'
                },
                {
                    target: '.timeline-container',
                    title: 'Timeline',
                    description: 'Arrange clips on tracks. Use tools to split, trim, and organize your content.'
                }
            ],

            currentStep: 0,

            start() {
                this.currentStep = 0;
                this.showStep();
            },

            showStep() {
                this.removeHighlight();
                
                if (this.currentStep >= this.steps.length) {
                    this.end();
                    return;
                }

                const step = this.steps[this.currentStep];
                const target = document.querySelector(step.target);
                
                if (!target) {
                    this.currentStep++;
                    this.showStep();
                    return;
                }

                // Highlight target
                target.style.boxShadow = '0 0 0 4px var(--accent-primary), 0 0 20px rgba(233, 69, 96, 0.5)';
                target.style.position = 'relative';
                target.style.zIndex = '1000';

                // Show tooltip
                const tooltip = document.createElement('div');
                tooltip.id = 'tourTooltip';
                tooltip.style.cssText = `
                    position: fixed;
                    background: var(--bg-secondary);
                    border: 1px solid var(--accent-primary);
                    border-radius: 12px;
                    padding: 20px;
                    max-width: 300px;
                    z-index: 1001;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
                `;
                tooltip.innerHTML = `
                    <h3 style="margin: 0 0 8px; color: var(--accent-primary);">${step.title}</h3>
                    <p style="margin: 0 0 16px; color: var(--text-secondary); font-size: 14px;">${step.description}</p>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: var(--text-muted); font-size: 12px;">${this.currentStep + 1} of ${this.steps.length}</span>
                        <div>
                            <button class="btn btn-ghost" id="tourSkip">Skip</button>
                            <button class="btn btn-primary" id="tourNext">${this.currentStep === this.steps.length - 1 ? 'Finish' : 'Next'}</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(tooltip);

                // Position tooltip
                const rect = target.getBoundingClientRect();
                tooltip.style.top = `${rect.bottom + 20}px`;
                tooltip.style.left = `${Math.min(rect.left, window.innerWidth - 320)}px`;

                // Event listeners
                document.getElementById('tourNext').addEventListener('click', () => {
                    this.currentStep++;
                    this.showStep();
                });

                document.getElementById('tourSkip').addEventListener('click', () => {
                    this.end();
                });
            },

            removeHighlight() {
                const tooltip = document.getElementById('tourTooltip');
                if (tooltip) tooltip.remove();

                document.querySelectorAll('[style*="box-shadow"]').forEach(el => {
                    el.style.boxShadow = '';
                    el.style.zIndex = '';
                });
            },

            end() {
                this.removeHighlight();
                NotificationManager.success('Tour Complete', 'You\'re ready to start editing!');
                localStorage.setItem('capcut_tour_completed', 'true');
            }
        };

        // ==================== APPLICATION INITIALIZATION ====================
        const App = {
            async init() {
                console.log('üé¨ CapCut Pro - Initializing...');

                // Initialize managers
                NotificationManager.init();
                MediaManager.init();
                TimelineManager.init();
                PreviewManager.init();
                PropertiesManager.init();
                ContextMenuManager.init();
                SidebarManager.init();
                TextEditorManager.init();
                ExportManager.init();
                ProjectManager.init();
                ShortcutsManager.init();
                DragDropManager.init();
                ResizeManager.init();
                VideoRenderer.init();
                PerformanceMonitor.init();

                // Initialize audio engine
                try {
                    AudioEngine.init();
                } catch (e) {
                    console.warn('Audio engine initialization failed:', e);
                }

                // Update UI
                HistoryManager.updateButtons();

                // Check for auto-save
                setTimeout(() => {
                    ProjectManager.loadAutoSave();
                }, 500);

                // Show tour for first-time users
                if (!localStorage.getItem('capcut_tour_completed')) {
                    setTimeout(() => {
                        if (confirm('Welcome to CapCut Pro! Would you like a quick tour?')) {
                            TourManager.start();
                        } else {
                            localStorage.setItem('capcut_tour_completed', 'true');
                        }
                    }, 1000);
                }

                // Show welcome notification
                NotificationManager.success('CapCut Pro', 'Video editor loaded successfully!');

                console.log('‚úÖ CapCut Pro - Initialization complete!');
            }
        };

        // ==================== START APPLICATION ====================
        document.addEventListener('DOMContentLoaded', () => {
            App.init();
        });

        // ==================== SERVICE WORKER REGISTRATION (PWA Support) ====================
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Service worker would be registered here for PWA functionality
                console.log('PWA support available');
            });
        }

        // ==================== ERROR HANDLING ====================
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Error:', msg, 'at', url, lineNo, columnNo);
            NotificationManager.error('Error', 'An unexpected error occurred');
            return false;
        };

        window.onunhandledrejection = function(event) {
            console.error('Unhandled promise rejection:', event.reason);
        };

        // ==================== BEFORE UNLOAD WARNING ====================
        window.addEventListener('beforeunload', (e) => {
            if (AppState.timeline.tracks.some(t => t.clips.length > 0)) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                return e.returnValue;
            }
        });
    </script>
</body>
</html>
